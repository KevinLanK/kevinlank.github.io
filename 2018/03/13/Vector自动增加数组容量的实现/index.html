<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Vector自动增加数组容量的实现 | Hexo</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Vector自动增加数组容量的实现</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Vector自动增加数组容量的实现</h1><div class="post-meta">Mar 13, 2018</div><div class="post-content"><p>​    昨天在了解到ArrayList的自动扩容之后，忽然想到在Java的另外一个类-Vector里面，实现了数组的自动增长，然后看源码了解了一下。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	/**</span><br><span class="line">     * The array buffer into which the components of the vector are</span><br><span class="line">     * stored. The capacity of the vector is the length of this array buffer,</span><br><span class="line">     * and is at least large enough to contain all the vector&apos;s elements.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;Any array elements following the last element in the Vector are null.</span><br><span class="line">     *</span><br><span class="line">     * @serial</span><br><span class="line">     */</span><br><span class="line">    protected Object[] elementData;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The number of valid components in this &#123;@code Vector&#125; object.</span><br><span class="line">     * Components &#123;@code elementData[0]&#125; through</span><br><span class="line">     * &#123;@code elementData[elementCount-1]&#125; are the actual items.</span><br><span class="line">     *</span><br><span class="line">     * @serial</span><br><span class="line">     */</span><br><span class="line">    protected int elementCount;</span><br><span class="line">有趣的java.util.*List </span><br><span class="line">    /**</span><br><span class="line">     * The amount by which the capacity of the vector is automatically</span><br><span class="line">     * incremented when its size becomes greater than its capacity.  If</span><br><span class="line">     * the capacity increment is less than or equal to zero, the capacity</span><br><span class="line">     * of the vector is doubled each time it needs to grow.</span><br><span class="line">     *</span><br><span class="line">     * @serial</span><br><span class="line">     */</span><br><span class="line">    protected int capacityIncrement;</span><br></pre></td></tr></table></figure>
<p>​    在Vector内部，通过定义两个int变量来控制一个Vector数组的增长。elementCount指的是当前数组的使用量，capacityIncrement指的是在数组需要增加容量的时候增加的大小，elementData是一个底层的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private Object[] grow(int minCapacity) &#123;</span><br><span class="line">       return elementData = Arrays.copyOf(elementData,</span><br><span class="line">                                          newCapacity(minCapacity));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private Object[] grow() &#123;</span><br><span class="line">       return grow(elementCount + 1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Returns a capacity at least as large as the given minimum capacity.</span><br><span class="line">    * Will not return a capacity greater than MAX_ARRAY_SIZE unless</span><br><span class="line">    * the given minimum capacity is greater than MAX_ARRAY_SIZE.</span><br><span class="line">    *</span><br><span class="line">    * @param minCapacity the desired minimum capacity</span><br><span class="line">    * @throws OutOfMemoryError if minCapacity is less than zero</span><br><span class="line">    */</span><br><span class="line">   private int newCapacity(int minCapacity) &#123;</span><br><span class="line">       // overflow-conscious code</span><br><span class="line">       int oldCapacity = elementData.length;</span><br><span class="line">       int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="line">                                        capacityIncrement : oldCapacity);</span><br><span class="line">       if (newCapacity - minCapacity &lt;= 0) &#123;</span><br><span class="line">           if (minCapacity &lt; 0) // overflow</span><br><span class="line">               throw new OutOfMemoryError();</span><br><span class="line">           return minCapacity;</span><br><span class="line">       &#125;</span><br><span class="line">       return (newCapacity - MAX_ARRAY_SIZE &lt;= 0)</span><br><span class="line">           ? newCapacity</span><br><span class="line">           : hugeCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">       if (minCapacity &lt; 0) // overflow</span><br><span class="line">           throw new OutOfMemoryError();</span><br><span class="line">       return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">           Integer.MAX_VALUE :</span><br><span class="line">           MAX_ARRAY_SIZE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>​    跟ArrayList没有什么区别，Vector也是好几个方法套来套去实现数组的扩容，套来套去是为了保证代码的实用性和安全性。但是跟ArrayList实现方法不一样的是，在Vector内部，通过capacityIncrement来对数组的扩增进行长度控制，当数组需要扩容时，检查capacityIncrement的值，如果不非零，那么每次扩容都增加capacityIncrement的长度，如果非零，那么每次增加的量是原数组的长度，也就是oldCapacity。capacityIncrement的值是通过在建立一个Vector的时候在构造器中传入的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Constructs an empty vector with the specified initial capacity and</span><br><span class="line">    * capacity increment.</span><br><span class="line">    *</span><br><span class="line">    * @param   initialCapacity     the initial capacity of the vector</span><br><span class="line">    * @param   capacityIncrement   the amount by which the capacity is</span><br><span class="line">    *                              increased when the vector overflows</span><br><span class="line">    * @throws IllegalArgumentException if the specified initial capacity</span><br><span class="line">    *         is negative</span><br><span class="line">    */</span><br><span class="line">   public Vector(int initialCapacity, int capacityIncrement) &#123;</span><br><span class="line">       super();</span><br><span class="line">       if (initialCapacity &lt; 0)</span><br><span class="line">           throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       this.elementData = new Object[initialCapacity];</span><br><span class="line">       this.capacityIncrement = capacityIncrement;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这样子的实现使得Vector成为了可控的自增数组。</p>
<p>ArrayList实现：<a href="http://langxiaokai.top/2018/03/12/%E6%9C%89%E8%B6%A3%E7%9A%84java.util.*List/" target="_blank" rel="noopener">有趣的java.util.*List</a></p>
<h3 id="奇妙的设计思想"><a href="#奇妙的设计思想" class="headerlink" title="奇妙的设计思想"></a>奇妙的设计思想</h3><p>​    这段话是我在读完Stack的源码之后加上的。至于为什么加到这里，因为我是真的对JDK的设计思路感到神奇。<br>    Stack，这个栈，我印象中在我学习数据结构的时候，自己创建一个栈，使用了各种绕来绕去的方法，写上两三百行的代码(当然，这个并不包括注释，就算包括，也不会再多太多)，这之间可能自己都绕不过来，然后才实现了一个勉强能够使用的Stack类。但是当我看到源码中的Stack，继承了Vector数组，这也是我把这段话写到这里的原因，然后Vector定义了一些极具通用性的方法，然后直接调用，付出的只是些参数，例如Stack的长度，然后就把一个Stack类写完了。哇，神奇的设计思路。</p>
</div><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/源码解读/">源码解读</a></div><div class="post-nav"><a class="pre" href="/2018/03/18/检测String的不可变性及String赋值的实质/">检测String的不可变性及String赋值的实质</a><a class="next" href="/2018/03/12/有趣的java-util-Link/">有趣的java.util.*Link</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Ubuntu/" style="font-size: 15px;">Ubuntu</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/锁/" style="font-size: 15px;">锁</a> <a href="/tags/文章整理/" style="font-size: 15px;">文章整理</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/Java新特性/" style="font-size: 15px;">Java新特性</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/TCP-IP/" style="font-size: 15px;">TCP/IP</a> <a href="/tags/源码解读/" style="font-size: 15px;">源码解读</a> <a href="/tags/系统搭建/" style="font-size: 15px;">系统搭建</a> <a href="/tags/内存屏障/" style="font-size: 15px;">内存屏障</a> <a href="/tags/双轴快排/" style="font-size: 15px;">双轴快排</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/单例/" style="font-size: 15px;">单例</a> <a href="/tags/同步语义/" style="font-size: 15px;">同步语义</a> <a href="/tags/杂记/" style="font-size: 15px;">杂记</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/线程通信/" style="font-size: 15px;">线程通信</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/17/HashMap在并发环境下出现的错误/">HashMap在并发环境下出现的错误</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/21/Java中不可变的一般类型/">Java中不可变的一般类型 </a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/18/Java中的Concurrent类的实现/">Java中的Concurrent类的实现 </a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/17/可重入锁ReentrantLock和读写锁ReentrantReadWriteLock/">可重入锁ReentrantLock和读写锁ReentrantReadWriteLock </a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/17/AQS/">AQS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/16/TCP连接的建立与关闭/">TCP连接的建立与关闭</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/15/偏向锁、轻量级锁、重量级锁/">偏向锁、轻量级锁、重量级锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/15/Java中的锁/">Java中的锁 </a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/14/Java中的并发/">Java中的并发 </a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/14/Java内存模型/">Java内存模型</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://cokid.cc" title="Cokid" target="_blank">Cokid</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>