<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java中不可变的一般类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/21/Java中不可变的一般类型/" class="article-date">
  <time datetime="2018-04-21T07:48:11.000Z" itemprop="datePublished">2018-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/21/Java中不可变的一般类型/">Java中不可变的一般类型 </a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java中不可变的一般类型"><a href="#Java中不可变的一般类型" class="headerlink" title="Java中不可变的一般类型"></a>Java中不可变的一般类型</h1><p>​    这几天有在读一些关于并发的书，然后在一本书上看到了这么一个描述：在Java中，Integer属于不变对象，也就是对象一旦被创建，就不可能被修改。这段描述是讲Integer的对象，当初始化之后这个对象的内容就不能够改变了，对Integer的操作，都会新建一个对象。<br>    换句话讲，Integer对象与Streing表现出来的性质是一样的。然后了解了一下，发现在Java中，不仅仅是Integer类，Double、Float等类都是不可变的。然后我测试了一下基本类型的不变性。</p>
<h3 id="自动包装"><a href="#自动包装" class="headerlink" title="自动包装"></a>自动包装</h3><p>​    Java中存在着这么一个机制：int、double、float等都是一些声明变量的关键字，通过这些关键字进行声明的变量，会在实际处理的时候自动封装成为包装器类型。也就是说，int变量会被包装Integer，同理double和float等也会进行相应处理。</p>
<h3 id="不变性的测试"><a href="#不变性的测试" class="headerlink" title="不变性的测试"></a>不变性的测试</h3><p>​    在包装器类型中，声明的对象是不可变类型，那么声明的基本数据类型是不是也是不可变的，我测试了一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class AutoPackageTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        integerTest();</span><br><span class="line">        longTest();</span><br><span class="line">        doubleTest();</span><br><span class="line">        floatTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void integerTest()&#123;</span><br><span class="line"></span><br><span class="line">        System.out.print(&quot;This is IntegerTest:&quot;);</span><br><span class="line"></span><br><span class="line">        Integer integer = 1;</span><br><span class="line">        Integer integerU = integer;</span><br><span class="line"></span><br><span class="line">        int a = 1;</span><br><span class="line">        int b = a;</span><br><span class="line"></span><br><span class="line">        a++;integer++;</span><br><span class="line"></span><br><span class="line">        System.out.print(integer + &quot;   &quot;);</span><br><span class="line">        System.out.print(integerU + &quot;   &quot;);</span><br><span class="line">        System.out.print(a+ &quot;   &quot;);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void longTest()&#123;</span><br><span class="line"></span><br><span class="line">        System.out.print(&quot;This is LongTest:&quot;);</span><br><span class="line"></span><br><span class="line">        Long aLong = 1L;</span><br><span class="line">        Long aLongU = aLong;</span><br><span class="line"></span><br><span class="line">        long a = 1L;</span><br><span class="line">        long b = a;</span><br><span class="line"></span><br><span class="line">        aLong++;a++;</span><br><span class="line"></span><br><span class="line">        System.out.print(aLong + &quot;   &quot;);</span><br><span class="line">        System.out.print(aLongU + &quot;   &quot;);</span><br><span class="line">        System.out.print(a+ &quot;   &quot;);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void doubleTest()&#123;</span><br><span class="line"></span><br><span class="line">        System.out.print(&quot;This is DoubleTest:&quot;);</span><br><span class="line"></span><br><span class="line">        Double c = 1D;</span><br><span class="line">        Double d = c;</span><br><span class="line"></span><br><span class="line">        double a = 1D;</span><br><span class="line">        double b = a;</span><br><span class="line"></span><br><span class="line">        c++;a++;</span><br><span class="line"></span><br><span class="line">        System.out.print(c + &quot;   &quot;);</span><br><span class="line">        System.out.print(d + &quot;   &quot;);</span><br><span class="line">        System.out.print(a+ &quot;   &quot;);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void floatTest()&#123;</span><br><span class="line"></span><br><span class="line">        System.out.print(&quot;This is FloatTest:&quot;);</span><br><span class="line"></span><br><span class="line">        Float c = 1F;</span><br><span class="line">        Float d = c;</span><br><span class="line"></span><br><span class="line">        float a = 1;</span><br><span class="line">        float b = a;</span><br><span class="line"></span><br><span class="line">        c++;a++;</span><br><span class="line"></span><br><span class="line">        System.out.print(c + &quot;   &quot;);</span><br><span class="line">        System.out.print(d + &quot;   &quot;);</span><br><span class="line">        System.out.print(a+ &quot;   &quot;);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    运行上述程序，产生的结果是这样的：<br><img src="/2018/04/21/Java中不可变的一般类型/Java不可变对象.png" alt="Java中的不可变基本类型"><br>    也就是说，通过基本数据类型定义的变量，实际上也会产生一个不可变对象，在经过操作之后，也是通过新建一个新的对象来实现的。<br>    所以在实际应用过程中，对基本类型或者自动包装类型加锁的时候，要注意加锁的对象，是不是当前的实例，新建对象的创建可能会造成加锁对象的改变。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/21/Java中不可变的一般类型/" data-id="cjjmjmhs60001rbmcs7sqnt0w" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码解读/">源码解读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java中的Concurrent类的实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/18/Java中的Concurrent类的实现/" class="article-date">
  <time datetime="2018-04-18T07:46:53.000Z" itemprop="datePublished">2018-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/18/Java中的Concurrent类的实现/">Java中的Concurrent类的实现 </a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java中的Concurrent类的实现"><a href="#Java中的Concurrent类的实现" class="headerlink" title="Java中的Concurrent类的实现"></a>Java中的Concurrent类的实现</h1><p>​    在Jdk的实现中，对于HashMap的实现是线程非安全的，在大量并发读的情况下，HashMap能够保持线程安全，但是在存在大量写的情况下，HashMap将会出现并发错误，所以JDK实现了ConcurrentHashMap来保证线程安全并且高效的HashMap。<br>    JDK还实现了ConcurrentLinkedQueue来实现在并发中的非阻塞的队列和BlockingQueue的阻塞线程的队列。</p>
<h3 id="HashMap的实现"><a href="#HashMap的实现" class="headerlink" title="HashMap的实现"></a>HashMap的实现</h3><p>​    在ConcurrentHashMap讲述之前，先对HashMap的底层实现做一下总结。<br>    HashMap：散列表。在Java中HashMap通过分离链接法来进行实现，也就是通过数组+链表的方法来进行实现。在JDK1.8后，如果有一个散列表某个散列值对应的链表的元素超过一定值，这个对应的链表将会转化为红黑树的实现，这个值默认为8。也就是说，实际上HashMap的实现为数组+链表+红黑树的实现。<br>    在HashMap的实现中，如果HashMap的数组容量不足，也就是散列后超出现有容量大小，将会对数组大小进行扩增，将新的数组大小扩展成为当前状态的两倍，然后将数据重新散列到新的数组上，所以扩容阶段将会消耗很多资源，并且在并发过程中，出现问题的地方就在扩容阶段。</p>
<h5 id="HashMap的get"><a href="#HashMap的get" class="headerlink" title="HashMap的get"></a>HashMap的get</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    HashMap将会对关键词key进行hash，然后在数组中进行查找到这个值，然后对整个整个链表进行查找查看是否有这个key对应的value。</p>
<h5 id="HashMap的put"><a href="#HashMap的put" class="headerlink" title="HashMap的put"></a>HashMap的put</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​    首先先判断是否需要扩容，然后根据key的散列查找到数组索引，然后新建节点进行插入，插入过程中分别按照红黑树或者链表的方法进行插入。</p>
<h3 id="ConcurrentHashMap的实现"><a href="#ConcurrentHashMap的实现" class="headerlink" title="ConcurrentHashMap的实现"></a>ConcurrentHashMap的实现</h3><p>​    在并发环境下如果同时对HashMap进行写操作，那么HashMap将会导致内部的Entry数据会链表形成环状数据结构，然后Entry的next节点将永远不为空，也就是会产生死循环获取Entry。而如果对写过程进行加锁，那么错误将不会发生，但是会导致在线程竞争激烈的情况下会出现大量线程阻塞的状态，进而导致效率低下。<br>    针对这个问题，ConcurrentHashMap提供了锁分段技术来提高并发访问率。<br>    分段锁也就是对当前线程访问的数组部分进行加锁，而不是对整个数组进行加锁，通过这种方法，实现写入的时候只有部分加锁，而其他部分将允许线程正常访问。</p>
<h3 id="ConcurrentLinkedQueue的实现"><a href="#ConcurrentLinkedQueue的实现" class="headerlink" title="ConcurrentLinkedQueue的实现"></a>ConcurrentLinkedQueue的实现</h3><p>​    在普通的队列实现中，在并发环境下，那么两个线程对同一个队列进行push的时候，尾节点指向两个不同的新加入节点，那么将会有一个节点被销毁；如果是两个线程同时对一个元素进行pop操作，也会出现错误。在JDK里面，实现了非阻塞的队列和阻塞队列，非阻塞队列被实心为ConcurrentQueue，阻塞队列实现为BlockingQueue。<br>    在ConcurrentQueue中，采用CAS算法来对队列中的元素进行写操作。并且在队列内部维护两个节点：head节点和tail节点，head节点指向队列的尾节点。</p>
<blockquote>
<h6 id="入队列和出队列"><a href="#入队列和出队列" class="headerlink" title="入队列和出队列"></a>入队列和出队列</h6><p>不同于一般的队列，ConcurrentQueue在入队列和出队列中采用了不一样的方法。<br>在入队列调整tail节点的时候，会首先判断tail节点当前的指向，如果添加的节点为第一个元素，那么head和tail节点中的next都会指向这个节点，在添加非首节点的时候，判断tail的节点中的next节点，如果为空，会将tail节点的next节点设置为添加节点，如果不为空，将tail节点指向添加节点。<br>在出队列的时候，先检查当前的head节点，如果当前head节点指向的节点元素为空，那么表示已经有其他线程将头节点取走，继续判断下一个头节点，直到能够取出当前节点的元素。</p>
</blockquote>
<h3 id="BlockingQueue阻塞队列"><a href="#BlockingQueue阻塞队列" class="headerlink" title="BlockingQueue阻塞队列"></a>BlockingQueue阻塞队列</h3><p>​    在阻塞队列中对队列的插入和移除操作进行了扩展：</p>
<blockquote>
<p>支持阻塞的插入方法：当队列满的时候，队列阻塞插入元素的线程，直到队列不满。<br>支持阻塞的移除方法：当队列为空的时候，获取元素的线程会阻塞直到队列变为非空。</p>
</blockquote>
<p>​    在JDK7里面，一共提供了7个阻塞队列：</p>
<blockquote>
<p>ArrayBlockingQueue：由数组结构组成的有界阻塞队列<br>LinkedBlockingQueue：由链表结构组成的有界阻塞队列<br>PriorityBlockingQueue：支持优先级排序的无界阻塞队列<br>DelayQueue：使用优先级队列实现的无界阻塞队列<br>SynchronousQueue：不储存元素的阻塞队列<br>LinkedTransferQueue：由链表结构组成的无界阻塞队列<br>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</p>
</blockquote>
<p>​    在队列中元素为空的时候，如果有线程想要获取元素，那么将会进行等待，当有其他线程添加元素到队列中的时候，JDK采用了多种不同的模式提醒阻塞线程：Condition、LockSupport的park对线程进行唤醒操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/18/Java中的Concurrent类的实现/" data-id="cjjmjmhsa0003rbmc47qqny15" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码解读/">源码解读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-可重入锁ReentrantLock和读写锁ReentrantReadWriteLock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/17/可重入锁ReentrantLock和读写锁ReentrantReadWriteLock/" class="article-date">
  <time datetime="2018-04-17T07:46:00.000Z" itemprop="datePublished">2018-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/17/可重入锁ReentrantLock和读写锁ReentrantReadWriteLock/">可重入锁ReentrantLock和读写锁ReentrantReadWriteLock </a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="可重入锁ReentrantLock和读写锁ReentrantReadWriteLock"><a href="#可重入锁ReentrantLock和读写锁ReentrantReadWriteLock" class="headerlink" title="可重入锁ReentrantLock和读写锁ReentrantReadWriteLock"></a>可重入锁ReentrantLock和读写锁ReentrantReadWriteLock</h1><p>​    Java中加入了可重入锁的具体实现：ReentrantLock，还有读写锁的实现：ReentrantReadWriteLock。</p>
<h3 id="ReentrantLock的底层实现"><a href="#ReentrantLock的底层实现" class="headerlink" title="ReentrantLock的底层实现"></a>ReentrantLock的底层实现</h3><p>​    ReentrantLock是维护了一个内部类Sync来实现的，这个内部类Sync继承了AQS，实现了不公平的加锁和解锁。并且实现了NonfairSync和FairSync来实现可重入锁的公平性和非公平性。</p>
<h3 id="ReentrantLock实现可重入获取锁和解锁"><a href="#ReentrantLock实现可重入获取锁和解锁" class="headerlink" title="ReentrantLock实现可重入获取锁和解锁"></a>ReentrantLock实现可重入获取锁和解锁</h3><p>​    在ReentrantLock中的Sync中的加锁的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@ReservedStackAccess</span><br><span class="line">        final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc = c + acquires;</span><br><span class="line">                if (nextc &lt; 0) // overflow</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​    在方法nonfairTryAcquire中，先判断当前的共享资源有没有线程已经加锁，如果没有，使用CAS加锁，返回true，如果已经获得了锁，判断获得锁的线程是不是当前线程，如果是，同步状态+1，否则返回错误。<code>如果在加锁过程中采用了超时加锁，那么具体实现是AQS内的实现方法。</code><br>    ReentrantLock实现解锁的方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ReservedStackAccess</span><br><span class="line">       protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">           int c = getState() - releases;</span><br><span class="line">           if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">               throw new IllegalMonitorStateException();</span><br><span class="line">           boolean free = false;</span><br><span class="line">           if (c == 0) &#123;</span><br><span class="line">               free = true;</span><br><span class="line">               setExclusiveOwnerThread(null);</span><br><span class="line">           &#125;</span><br><span class="line">           setState(c);</span><br><span class="line">           return free;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>​    如果该锁被获取了n次，那么前n-1次的释放锁会返回false，只有同步状态完全释放了，才能够返回true。该方法把0作为释放条件，同步状态为0的时候才将占有线程设置为null，返回true，表示释放成功。</p>
<h3 id="ReentrantLock实现公平性加锁和非公平性加锁"><a href="#ReentrantLock实现公平性加锁和非公平性加锁" class="headerlink" title="ReentrantLock实现公平性加锁和非公平性加锁"></a>ReentrantLock实现公平性加锁和非公平性加锁</h3><p>​    在ReentrantLock的实现中，默认的加锁方法就是非公平性的加锁，也就是说，虽然实现了内部类NonfairSync继承了Sync，但是加锁的方法只是调用了Sync中的加锁方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在公平锁的加锁方法里，重新进行了方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@ReservedStackAccess</span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc = c + acquires;</span><br><span class="line">                if (nextc &lt; 0)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​    公平锁是按照申请顺序来进行加锁的，也就是说是FIFO顺序，所以在方法里面会先判断有没有前驱节点，如果没有前驱节点，那么这个节点就是头节点，可以进行加锁操作，这也就是通过实现AQS来搭建的好处，可以非常清楚的判断当前队列信息。<br>    公平锁的解锁方式跟非公平锁并无区别。设定一个ReentrantLock是公平锁的实现还是非公平锁的实现，可以通过在构造函数中传入boolean变量来决定。</p>
<h4 id="ReentrantLock中的公平锁和非公平锁对比"><a href="#ReentrantLock中的公平锁和非公平锁对比" class="headerlink" title="ReentrantLock中的公平锁和非公平锁对比"></a>ReentrantLock中的公平锁和非公平锁对比</h4><p>​    在公平锁中，每一个线程都会得到锁，也就是都能得到运行机会，而在非公平锁中，如果一个线程在使用CAS加锁前恰好有一个其它线程得到了锁，那么这个线程将会加锁失败，而如果足够凑巧，那么非公平锁将会存在饥饿现象。<br>    但是非公平锁与公平锁相比，非公平锁在执行过程中线程切换较少，所以系统的开销更小，保证了更大的吞吐量。</p>
<h3 id="ReentrantReadWriteLock的底层实现"><a href="#ReentrantReadWriteLock的底层实现" class="headerlink" title="ReentrantReadWriteLock的底层实现"></a>ReentrantReadWriteLock的底层实现</h3><p>​    ReentrantLock或者synchronized方法都属于独占锁，也就是在同一时刻只能有一个线程持有该锁，在ReentrantReadWriteLock中实现了读写锁，也就是在读状态下，允许多个线程同时获取一个锁。<br>    读写锁改进了在大量数据并发访问少量数据写入情况下的并发性能。<br>    同ReentrantLock一样，在读写锁中通过维护一个私有的Sync的类来实现底层方法的构建。通过实现一个ReadLock和一个WriteLock来实现方法的调用。</p>
<h4 id="ReentrantReadWriteLock实现读写状态"><a href="#ReentrantReadWriteLock实现读写状态" class="headerlink" title="ReentrantReadWriteLock实现读写状态"></a>ReentrantReadWriteLock实现读写状态</h4><p>​    在底层的内部类Sync的实现里，有这么几个变量和方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final int SHARED_SHIFT   = 16;</span><br><span class="line">static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);</span><br><span class="line">static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line">static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line">static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure>
<p>​    也就是在ReentrantReadWriteLock中，同步状态是在一个整型变量上通过使用“按位切割使用”来进行读写锁的区分的。在一个32位的变量上，高16位表示的是读状态，低16位表示的是写状态。<br>    读写锁获取读或者写的状态是通过位运算来进行的。假设同步状态为c，c&gt;&gt;&gt;SHARED_SHIFT表示的是读状态(无符号位右移16位)，c&amp;EXCLUSIVE_MASK表示的是写状态(抹去高16位)。<br>    所以，在c不等于0时，当写状态等于0 ，读状态大于0，也就是读锁已经被获取。</p>
<h3 id="ReentrantReadWriteLock中读锁和写锁对于获取释放的实现"><a href="#ReentrantReadWriteLock中读锁和写锁对于获取释放的实现" class="headerlink" title="ReentrantReadWriteLock中读锁和写锁对于获取释放的实现"></a>ReentrantReadWriteLock中读锁和写锁对于获取释放的实现</h3><p>​    写锁的获取等同于互斥锁的实现，也就是存在任何获取到锁的线程，这次获取就失败了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@ReservedStackAccess</span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            int w = exclusiveCount(c);</span><br><span class="line">            if (c != 0) &#123;</span><br><span class="line">                if (w == 0 || current != getExclusiveOwnerThread())</span><br><span class="line">                    return false;</span><br><span class="line">                if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                return false;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​    从代码中能够看出，在写锁的实现中，是包括可重入锁的实现的，也就是存在一个写的线程多次获取该所，但是因为按位切割使用的方法，在这里存在一个写锁的最大数量限制，当然，如果发生这种情况，大概系统已经宕机了。<br>    读锁是一个共享锁，当且仅当持有锁的线程持有的是写锁时候，读锁的获取才会失败：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@ReservedStackAccess</span><br><span class="line">        protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (exclusiveCount(c) != 0 &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                return -1;</span><br><span class="line">            int r = sharedCount(c);</span><br><span class="line">            if (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                if (r == 0) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = 1;</span><br><span class="line">                &#125; else if (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    if (rh == null ||</span><br><span class="line">                        rh.tid != LockSupport.getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    else if (rh.count == 0)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            return fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​    在Java6以后，获取读锁的方法中添加了当前线程获取锁的次数，所以实现复杂了许多。</p>
<h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><p>​    锁降级是一种线程安全的实现方式，是写锁降级成为读锁。降级锁是在拥有写锁的时候，持有写锁，先获取读锁，然后释放写锁的过程。<br>    这个过程中保证了数据的可见性，如果线程A不获取读锁而是直接释放写锁，如果此时有另外一个线程B获取写锁更改数据，那么线程A无法获取线程B中的数据更新，所以需要先持有读锁，然后阻塞另外线程B，知道A释放读锁之后，B才能够获取写锁进行数据更新。</p>
<p>​    <code>写在文章后：前两次次接触位运算的概念也是在JDK的实现中，一次是在LinkedList扩容的时候，通过位运算确定扩容的大小；另一次是JDK中对于折半查找的实现的时候，通过位运算确定中间量的位置大小。然后这里通过位运算确定读和写的状态，忽然发现JDK实现里面可真是喜欢使用位运算。Java怕不是基于位运算编程...</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/17/可重入锁ReentrantLock和读写锁ReentrantReadWriteLock/" data-id="cjjmjmht10014rbmc8ier3jrb" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码解读/">源码解读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AQS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/17/AQS/" class="article-date">
  <time datetime="2018-04-17T07:45:13.000Z" itemprop="datePublished">2018-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/17/AQS/">AQS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>​    在Java中，对于锁的默认实现是synchronized实现的加锁和解锁，而在JDK1.5之后Java中实现了ReentrantLock，ReentrantLock是当内置加锁机制不适用的时候，作为一种可以选择的高级功能。<br>    构建ReentrantLock的时候，采用了AQS(AbstractQueuedSynchronized)，也就是队列同步器作为基础框架。</p>
<h4 id="AbstractQueuedSynchronized"><a href="#AbstractQueuedSynchronized" class="headerlink" title="AbstractQueuedSynchronized"></a>AbstractQueuedSynchronized</h4><p>​    AbstractQueuedSynchronized是一个用来构建缩合同步组件的基础框架，它是一个高度抽象的类，除去ReentrantLock外，ReentrantReadWriteLock和CountDownLatch等一些不同类型的同步组件也是基于AQS实现的。AQS中使用了一个int类型的成员变量来表示同步状态，并且通过内置的FIFO队列来实现资源获取线程的排队动作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">state变量：</span><br><span class="line">    private volatile int state;</span><br><span class="line">    protected final int getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">    protected final void setState(int newState) &#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line">    protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">        return STATE.compareAndSet(this, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​    AQS定义了一个volatile的int类型的表示同步状态变量，提供了同步状态的访问和修改方法：</p>
<blockquote>
<p>getState():获取当前的同步状态<br>setState(int newState):设置当前的同步状态<br>compareAndSetState(int expect,int update):使用CAS设置当前状态，这种方法能够保证状态的原子性</p>
</blockquote>
<p>​    AQS还提供了可以重写的许多方法以及模板方法：</p>
<p><code>可重写方法：</code></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>protected boolean tryAcquire(int arg)</td>
<td>独占式获取同步状态，实现方法查询当前状态并判断同步状态是否符合预期，使用CAS进行同步状态的设置</td>
</tr>
<tr>
<td>protected boolean tryRelease(int arg)</td>
<td>独占式释放同步状态，等待获取状态的线程将有机会获取同步状态</td>
</tr>
<tr>
<td>protected int tryAcquireShared(int arg)</td>
<td>共享式获得同步状态</td>
</tr>
<tr>
<td>protected boolean tryReleaseShared(int arg)</td>
<td>共享式释放同步状态</td>
</tr>
<tr>
<td>protected boolean isHeldExclusively()</td>
<td>判断同步器是否在独占模式下被线程占用</td>
</tr>
</tbody>
</table>
<p><code>模板方法：</code></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>public final void acquire(int arg)</td>
<td>抢占式获取同步状态</td>
</tr>
<tr>
<td>public final void acquireInterruptibly(int arg)</td>
<td>响应中断的抢占式获取同步状态</td>
</tr>
<tr>
<td>public final boolean tryAcquireNanos(int arg, long nanosTimeout)</td>
<td>在acquireInterruptibly的基础上加入超时时间，在时间内获取到锁才成功</td>
</tr>
<tr>
<td>public final boolean release(int arg)</td>
<td>独占式释放同步状态，当释放成功之后，会唤醒在同步队列中的第一个节点中的线程</td>
</tr>
<tr>
<td>public final boolean releaseShared(int arg)</td>
<td>共享式的释放同步状态</td>
</tr>
<tr>
<td>public final void acquireShared(int arg)</td>
<td>共享式的获取同步状态，在同一时刻内能够有多个线程获取到同步状态</td>
</tr>
<tr>
<td>public final void acquireSharedInterruptibly(int arg)</td>
<td>响应中断的共享获取同步状态</td>
</tr>
<tr>
<td>public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</td>
<td>在响应中断的共享获取同步状态的基础上加入超时时间</td>
</tr>
<tr>
<td>public final Collection getSharedQueuedThreads()</td>
<td>获取在同步队列上的线程的集合</td>
</tr>
</tbody>
</table>
<h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p>​    AQS通过在内部维护一个同步队列来实现多个线程对同一个资源访问情况下的线程状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">AQS中同步队列的实现：</span><br><span class="line">static final class Node &#123;</span><br><span class="line">        static final Node SHARED = new Node();</span><br><span class="line">        static final Node EXCLUSIVE = null;</span><br><span class="line">        static final int CANCELLED =  1;</span><br><span class="line">        static final int SIGNAL    = -1;</span><br><span class="line">        static final int CONDITION = -2;</span><br><span class="line">        static final int PROPAGATE = -3;</span><br><span class="line">        volatile int waitStatus;</span><br><span class="line">        volatile Node prev;</span><br><span class="line">        volatile Node next;</span><br><span class="line">        volatile Thread thread;</span><br><span class="line">        Node nextWaiter;</span><br><span class="line">        final boolean isShared() &#123;</span><br><span class="line">            return nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line">        final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            if (p == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            else</span><br><span class="line">                return p;</span><br><span class="line">        &#125;</span><br><span class="line">        Node() &#123;&#125;</span><br><span class="line">        Node(Node nextWaiter) &#123;</span><br><span class="line">            this.nextWaiter = nextWaiter;</span><br><span class="line">            THREAD.set(this, Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line">        Node(int waitStatus) &#123;</span><br><span class="line">            WAITSTATUS.set(this, waitStatus);</span><br><span class="line">            THREAD.set(this, Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line">        final boolean compareAndSetWaitStatus(int expect, int update) &#123;</span><br><span class="line">            return WAITSTATUS.compareAndSet(this, expect, update);</span><br><span class="line">        &#125;</span><br><span class="line">        final boolean compareAndSetNext(Node expect, Node update) &#123;</span><br><span class="line">            return NEXT.compareAndSet(this, expect, update);</span><br><span class="line">        &#125;</span><br><span class="line">        final void setPrevRelaxed(Node p) &#123;</span><br><span class="line">            PREV.set(this, p);</span><br><span class="line">        &#125;</span><br><span class="line">        private static final VarHandle NEXT;</span><br><span class="line">        private static final VarHandle PREV;</span><br><span class="line">        private static final VarHandle THREAD;</span><br><span class="line">        private static final VarHandle WAITSTATUS;</span><br><span class="line">        static &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                MethodHandles.Lookup l = MethodHandles.lookup();</span><br><span class="line">                NEXT = l.findVarHandle(Node.class, &quot;next&quot;, Node.class);</span><br><span class="line">                PREV = l.findVarHandle(Node.class, &quot;prev&quot;, Node.class);</span><br><span class="line">                THREAD = l.findVarHandle(Node.class, &quot;thread&quot;, Thread.class);</span><br><span class="line">                WAITSTATUS = l.findVarHandle(Node.class, &quot;waitStatus&quot;, int.class);</span><br><span class="line">            &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class="line">                throw new Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​    在同步队列里面，waitStatus为线程的等待状态，包括了这样几种情况：</p>
<blockquote>
<p>CANCELLED，值为1，线程从同步队列中取消等待<br>SIGNAL，值为-1，后继节点的线程处于等待状态<br>CONDITION，值为-2，节点等待在Condition上，等待其他线程对Condition的调用，进而进入到同步队列<br>PROPAGATE，值为-3，笑一次共享式同步状态会无条件地被传播下去<br>INITIAL，值为0，表示初始状态</p>
</blockquote>
<p>​    在同步队列中，包含了两个节点类型的引用：头节点和尾节点。添加尾节点通过CAS添加，只有当前节点符合预期才会添加进去，并且尾节点引用指向队列的尾节点。<br>    同步队列遵循FIFO，也就是先到达同步队列的线程将优先得到同步状态，当头节点释放同步状态之后，将会唤醒在同步队列中等待的下一个节点的线程，并且当后继节点在获取同步状态成功后会把自己设置为头节点。<br>    再同步队列中的线程会采用自旋的方式来判断自己是否能够获取到同步状态，判断的方式是只有判断前驱节点是头节点的情况下才开始自旋获取同步状态，否则节点中的线程将会进入等待状态。并且通过只有前驱节点是头节点，才尝试获取同步状态，只有成功以后才会把自己设置为头节点，这样提供了并发条件下出现竞争的安全。<br>    共享式获取同步状态或者释放同步状态的情况即读写锁的情况：只有在存在读锁或者不上锁的情况下，读锁的申请才会成功，而只有不上锁的时候写锁才能够获取成功。并且在Java中，ReentrantReadWriteLock的实现就是通过AQS来实现的。<br>    在独占式超时获取同步状态的时候，需要判断当前自旋时间是否超过超时等待时间，如果已经超过，那么获取同步状态就不会成功，否则在未超时的时候同获取独占式同步状态。</p>
<h4 id="Codition"><a href="#Codition" class="headerlink" title="Codition"></a>Codition</h4><p>​    除去维护一个同步队列，AQS还维护一个Codition（等待队列）来存储等待状态的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line">public class ConditionObject implements Condition, java.io.Serializable &#123;</span><br><span class="line">        private static final long serialVersionUID = 1173984872572414699L;</span><br><span class="line">        private transient Node firstWaiter;</span><br><span class="line">        private transient Node lastWaiter;</span><br><span class="line">        public ConditionObject() &#123; &#125;</span><br><span class="line">        private Node addConditionWaiter() &#123;</span><br><span class="line">            Node t = lastWaiter;</span><br><span class="line">            if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Node node = new Node(Node.CONDITION);</span><br><span class="line"></span><br><span class="line">            if (t == null)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            else</span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        private void doSignal(Node first) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                if ( (firstWaiter = first.nextWaiter) == null)</span><br><span class="line">                    lastWaiter = null;</span><br><span class="line">                first.nextWaiter = null;</span><br><span class="line">            &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                     (first = firstWaiter) != null);</span><br><span class="line">        &#125;</span><br><span class="line">        private void doSignalAll(Node first) &#123;</span><br><span class="line">            lastWaiter = firstWaiter = null;</span><br><span class="line">            do &#123;</span><br><span class="line">                Node next = first.nextWaiter;</span><br><span class="line">                first.nextWaiter = null;</span><br><span class="line">                transferForSignal(first);</span><br><span class="line">                first = next;</span><br><span class="line">            &#125; while (first != null);</span><br><span class="line">        &#125;</span><br><span class="line">        private void unlinkCancelledWaiters() &#123;</span><br><span class="line">            Node t = firstWaiter;</span><br><span class="line">            Node trail = null;</span><br><span class="line">            while (t != null) &#123;</span><br><span class="line">                Node next = t.nextWaiter;</span><br><span class="line">                if (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                    t.nextWaiter = null;</span><br><span class="line">                    if (trail == null)</span><br><span class="line">                        firstWaiter = next;</span><br><span class="line">                    else</span><br><span class="line">                        trail.nextWaiter = next;</span><br><span class="line">                    if (next == null)</span><br><span class="line">                        lastWaiter = trail;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    trail = t;</span><br><span class="line">                t = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public final void signal() &#123;</span><br><span class="line">            if (!isHeldExclusively())</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            if (first != null)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br><span class="line">        public final void signalAll() &#123;</span><br><span class="line">            if (!isHeldExclusively())</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            if (first != null)</span><br><span class="line">                doSignalAll(first);</span><br><span class="line">        &#125;</span><br><span class="line">        public final void awaitUninterruptibly() &#123;</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            int savedState = fullyRelease(node);</span><br><span class="line">            boolean interrupted = false;</span><br><span class="line">            while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(this);</span><br><span class="line">                if (Thread.interrupted())</span><br><span class="line">                    interrupted = true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">                selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        private static final int REINTERRUPT =  1;</span><br><span class="line">        private static final int THROW_IE    = -1;</span><br><span class="line">        private int checkInterruptWhileWaiting(Node node) &#123;</span><br><span class="line">            return Thread.interrupted() ?</span><br><span class="line">                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                0;</span><br><span class="line">        &#125;</span><br><span class="line">        private void reportInterruptAfterWait(int interruptMode)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">            if (interruptMode == THROW_IE)</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">            else if (interruptMode == REINTERRUPT)</span><br><span class="line">                selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        public final void await() throws InterruptedException &#123;</span><br><span class="line">            if (Thread.interrupted())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            int savedState = fullyRelease(node);</span><br><span class="line">            int interruptMode = 0;</span><br><span class="line">            while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(this);</span><br><span class="line">                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            if (node.nextWaiter != null) </span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            if (interruptMode != 0)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br><span class="line">        public final long awaitNanos(long nanosTimeout)</span><br><span class="line">                throws InterruptedException &#123;</span><br><span class="line">            if (Thread.interrupted())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">            final long deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">            long initialNanos = nanosTimeout;</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            int savedState = fullyRelease(node);</span><br><span class="line">            int interruptMode = 0;</span><br><span class="line">            while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                if (nanosTimeout &lt;= 0L) &#123;</span><br><span class="line">                    transferAfterCancelledWait(node);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span><br><span class="line">                    LockSupport.parkNanos(this, nanosTimeout);</span><br><span class="line">                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">                    break;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            if (node.nextWaiter != null)</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            if (interruptMode != 0)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">            long remaining = deadline - System.nanoTime();</span><br><span class="line">            return (remaining &lt;= initialNanos) ? remaining : Long.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        public final boolean awaitUntil(Date deadline)</span><br><span class="line">                throws InterruptedException &#123;</span><br><span class="line">            long abstime = deadline.getTime();</span><br><span class="line">            if (Thread.interrupted())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            int savedState = fullyRelease(node);</span><br><span class="line">            boolean timedout = false;</span><br><span class="line">            int interruptMode = 0;</span><br><span class="line">            while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                if (System.currentTimeMillis() &gt;= abstime) &#123;</span><br><span class="line">                    timedout = transferAfterCancelledWait(node);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                LockSupport.parkUntil(this, abstime);</span><br><span class="line">                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            if (node.nextWaiter != null)</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            if (interruptMode != 0)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">            return !timedout;</span><br><span class="line">        &#125;</span><br><span class="line">        public final boolean await(long time, TimeUnit unit)</span><br><span class="line">                throws InterruptedException &#123;</span><br><span class="line">            long nanosTimeout = unit.toNanos(time);</span><br><span class="line">            if (Thread.interrupted())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">            final long deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            int savedState = fullyRelease(node);</span><br><span class="line">            boolean timedout = false;</span><br><span class="line">            int interruptMode = 0;</span><br><span class="line">            while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                if (nanosTimeout &lt;= 0L) &#123;</span><br><span class="line">                    timedout = transferAfterCancelledWait(node);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span><br><span class="line">                    LockSupport.parkNanos(this, nanosTimeout);</span><br><span class="line">                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">                    break;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            if (node.nextWaiter != null)</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            if (interruptMode != 0)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">            return !timedout;</span><br><span class="line">        &#125;</span><br><span class="line">        final boolean isOwnedBy(AbstractQueuedSynchronizer sync) &#123;</span><br><span class="line">            return sync == AbstractQueuedSynchronizer.this;</span><br><span class="line">        &#125;</span><br><span class="line">        protected final boolean hasWaiters() &#123;</span><br><span class="line">            if (!isHeldExclusively())</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            for (Node w = firstWaiter; w != null; w = w.nextWaiter) &#123;</span><br><span class="line">                if (w.waitStatus == Node.CONDITION)</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        protected final int getWaitQueueLength() &#123;</span><br><span class="line">            if (!isHeldExclusively())</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            int n = 0;</span><br><span class="line">            for (Node w = firstWaiter; w != null; w = w.nextWaiter) &#123;</span><br><span class="line">                if (w.waitStatus == Node.CONDITION)</span><br><span class="line">                    ++n;</span><br><span class="line">            &#125;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        protected final Collection&lt;Thread&gt; getWaitingThreads() &#123;</span><br><span class="line">            if (!isHeldExclusively())</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">            for (Node w = firstWaiter; w != null; w = w.nextWaiter) &#123;</span><br><span class="line">                if (w.waitStatus == Node.CONDITION) &#123;</span><br><span class="line">                    Thread t = w.thread;</span><br><span class="line">                    if (t != null)</span><br><span class="line">                        list.add(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​    等待队列也是一个FIFO队列，在每个节点上包括了一个线程的引用，这个引用是在Codition对象上等待的线程，当有一个线程调用了Codition对象的await()方法，那么这个线程将会释放锁，构造更节点并且进入等待队列。<br>    跟同步队列不同的是，在等待队列中，每个节点只是存储下一个节点的引用，而不存储前驱节点的引用。添加一个尾节点需要将当前尾节点的引用指向添加节点，并且在Condition里将尾节点修改。更新过程是由锁保证的，并不需要CAS进行更新。<br>    当调用Codition的signal()方法时，会在唤醒首节点前，将节点移到同步队列。而调用signalAll()方法会将整个等待队列中的节点移到同步队列中。</p>
<h3 id="Codition和Object的监视器模型"><a href="#Codition和Object的监视器模型" class="headerlink" title="Codition和Object的监视器模型"></a>Codition和Object的监视器模型</h3><p>​    在Object中，存在默认的监视器，即wait()、notify()和notifyALl()方法构成。在监视器模型中。一个对象拥有一个同步队列和等待队列，而在AQS中，可以拥有一个同步队列和多个等待队列，通过这种方式将等待的线程可以按照条件进行区分，即不满足不同条件的线程存储在不同的等待队列中。并且Codition可以精确的控制多个线程的休眠和唤醒。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/17/AQS/" data-id="cjjmjmhs10000rbmcpi7nw5l9" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码解读/">源码解读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-TCP连接的建立与关闭" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/16/TCP连接的建立与关闭/" class="article-date">
  <time datetime="2018-04-16T07:42:37.000Z" itemprop="datePublished">2018-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/16/TCP连接的建立与关闭/">TCP连接的建立与关闭</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="TCP连接的建立与关闭"><a href="#TCP连接的建立与关闭" class="headerlink" title="TCP连接的建立与关闭"></a>TCP连接的建立与关闭</h1><p>​    今天在某个技术群里水群的时候，忽然看到一个有意思的比较有意思的问题：HTTP请求中的TCP连接是由谁来关闭的，服务端还是客户端？然后追问了一下，实际表达的意思是在一个TCP连接中，发出第一个关闭请求的是服务端还是客户端？有什么场景会出现服务端先关闭的情况。<br>    然后今天有空的时候抓了一下包，来专门测试了一下这种情况。</p>
<h3 id="TCP连接的全双工性"><a href="#TCP连接的全双工性" class="headerlink" title="TCP连接的全双工性"></a>TCP连接的全双工性</h3><p>​    TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。<br>    首先要明确的一个概念是TCP的连接是基于全双工连接的，也就是说在同一时刻通信的两方能够进行两个方向上的双向传输。明确了这个概念之后再来考虑TCP连接关闭的情况。</p>
<h3 id="TCP连接的建立–三次挥手"><a href="#TCP连接的建立–三次挥手" class="headerlink" title="TCP连接的建立–三次挥手"></a>TCP连接的建立–三次挥手</h3><p>​    在TCP建立连接的开始，显示客户端发送一个报文段，来向服务端发起连接请求，并将TCP报文首部的SYN字段设置为1.<br>    第二步是服务器主机发送一个ACK报文段来确认TCP的连接允许，这个ACK报文段中SYN比特仍然被设置为1.<br>    最后一步是客户端发出的对于服务端发送的连接允许的ACK确认，用来确认已经接收到服务端主机的报文，这一步中将SYN设置为0。<br><img src="/2018/04/16/TCP连接的建立与关闭/TCP的三次握手.jpg" alt="TCP连接建立的三次握手"></p>
<h3 id="TCP连接的关闭–四次挥手"><a href="#TCP连接的关闭–四次挥手" class="headerlink" title="TCP连接的关闭–四次挥手"></a>TCP连接的关闭–四次挥手</h3><p>​    在标准的模式中，TCP关闭连接首先是由客户端发出一个含有FIN比特并且设置为1的报文段，用来通知服务端将要关闭连接。<br>    随后服务端向客户端发送一个ACK报文，执行被动关闭。<br>    一段时间后接收FIN报文段的服务端一端将会调用close关闭套接字，TCP将发送一个FIN。<br>    接收最终FIN的端，即最早发送FIN的客户端端将会发送一个ACK确认。<br>    <img src="/2018/04/16/TCP连接的建立与关闭/TCP的四次挥手.jpg" alt="TCP连接关闭的四次挥手"><br>    上面提到的TCP连接关闭是标准状态的连接关闭，也就是由客户端申请的关闭连接。</p>
<h3 id="实际抓包测试"><a href="#实际抓包测试" class="headerlink" title="实际抓包测试"></a>实际抓包测试</h3><p>​    在下午的时候，我抓了一下在TCP连接的建立和关闭过程中的TCP数据包，查了一下在关闭的时候究竟怎么关闭的情况。然后发现两种情况都是可能出现的，也就是说存在服务器主动发起关闭连接的情况和客户端主动发起关闭连接的情况。在测试用例前，我先ping了一下 <a href="http://www.baidu.com，" target="_blank" rel="noopener">www.baidu.com，</a> 得到了百度的ip119.75.213.61。</p>
<h4 id="TCP连接的抓包测试"><a href="#TCP连接的抓包测试" class="headerlink" title="TCP连接的抓包测试"></a>TCP连接的抓包测试</h4><p><img src="/2018/04/16/TCP连接的建立与关闭/TCP三次挥手建立连接的报文.png" alt="TCP三次握手建立连接的报文"><br>    我是通过在已经开启的浏览器中，打开新建标签页访问119.75.213.61对百度进行连接的方式打开的。能够很清楚的看到在TCP开始时共有三个TCP包，分别承载SYN和ACK来建立连接。<br>    当TCP成功建立连接，浏览器将会发送一条HTTP指令，申请服务器资源访问：GET / HTTP/1.1。<br><img src="/2018/04/16/TCP连接的建立与关闭/TCP进行数据传输.png" alt="TCP进行数据传输"><br>    之后的传输是将服务器的资源传输到浏览器上。</p>
<h4 id="TCP保证连接存活的机制"><a href="#TCP保证连接存活的机制" class="headerlink" title="TCP保证连接存活的机制"></a>TCP保证连接存活的机制</h4><p>​    在发送第一个HTTP请求的时候，在报文段头部包含了一些HTTP的设置，其中通过对Connection的设置，来进行持续连接的设置。<br><img src="/2018/04/16/TCP连接的建立与关闭/TCP保证连接存活.png" alt="TCP保证连接存活"><br>    将Connection设置为keep-alive来确保打开的连接是一个持续连接，也就是请求完一个对象之后不关闭连接。<br>    在连接开启过程中，探测到我的主机周期性的向服务端发送TCP Keep-Alive报文，并且等待服务端的确认来确保TCP连接的开启。<br><img src="/2018/04/16/TCP连接的建立与关闭/TCP连接保证存活状态.png" alt="TCP连接保证存活状态"></p>
<h4 id="客户端主动关闭TCP连接"><a href="#客户端主动关闭TCP连接" class="headerlink" title="客户端主动关闭TCP连接"></a>客户端主动关闭TCP连接</h4><p>​    这篇文章的主要目的是为了讨论客户端或者服务端主动关闭TCP连接的情况，然后抓包测试过程中，我发现仅通过在浏览器对百度的请求条件下就能够进行这两种测试。<br>    第一种条件是我主动关闭浏览器，然后我这边将会向服务端发送FIN报文，这种状况就是正常的TCP连接关闭的状态。<br><img src="/2018/04/16/TCP连接的建立与关闭/TCP在浏览器主动关闭的表现.png" alt="TCP在浏览器主动关闭的表现"><br>    在整个关闭过程中，浏览器发送第一个FIN包:Seq=345  ACK=31994，服务端接收并且发送一个ACK报文:Seq=31994  ACK=346。然后紧接着服务端发送一个对于服务端关闭连接的FIN报文，在这里能够看到的是服务端对这个报文的改变是刚刚传输的ACK报文段中修改了FIN状态：Seq=31994  ACK=346，浏览器接收到这个报文段，然后发送一个确认ACK：Seq=346 ACK=31995。连接就正式关闭了。<br>    在这整个过程中能看到的是发起关闭连接申请的是浏览器，服务器对其进行相应。</p>
<h4 id="服务端主动关闭连接"><a href="#服务端主动关闭连接" class="headerlink" title="服务端主动关闭连接"></a>服务端主动关闭连接</h4><p>​    在关闭状态还存在一种非常奇妙的情况，也就是服务端主动关闭连接。<br>    上一个测试例子，我是访问百度之直接关闭浏览器，在这一种情况下，我关闭的仅仅是标签页，也就是浏览器仍然开启，TCP连接建立和前期传输两者间并没有区别。<br><img src="/2018/04/16/TCP连接的建立与关闭/TCP连接在标签页关闭的情况.png" alt="TCP连接在标签页关闭的情况"><br>    服务端是在60s左右对我发送了一个FIN报文，但是，实际上我在41s左右的时刻就已经关闭了标签页了，也就是说，在我关闭标签页之后，浏览器仍然维持着这一条TCP连接，知道服务器检测到我长久不使用这个连接，才开始发送报文将连接关闭。<br>    在这种情况的时候，服务端会发送一个FIN报文段：Seq=32039  Ack=356，然后浏览器对这个报文段进行相应，发送一个FIN的报文段：Seq=356  Ack=32040，等服务器接收到之后，会发送一个ACK报文段：Seq=32040  Ack=357，连接关闭，当然这里关闭的连接，是服务端对客户端的连接，在这个状态出现之后，仍然能够看到浏览器向服务端发送的一些保持TCP连接的报文。<br>    所以，<code>在服务端主动关闭TCP连接的情况下，TCP的关闭阶段只会进行三次包的传输</code>，因为要保证用户可能存在的继续使用连接的情况，所以服务端不会向用户发送关闭确认的ACK，而是继续保持该连接一段时间，当达到某段时间后，如果依然没有进行过TCP的相应，那么服务端会直接发送RST报文段，将连接复原。<br>    <code>在整理这篇文章的时候，忽然考虑到服务端是怎样检测浏览器已经关闭了标签页的，然后打开了一个百度的页面进行测试。结果发现，哪怕是没有关闭标签页，持续开启百度页面，服务器依然会在一定时间后向我的浏览器发送FIN报文，然后进入上述状态，直到发送RST报文复原TCP连接。这样之后会在我再次访问当前百度页面的时候进行重新的TCP连接。</code>这个状态是与我是否关闭标签页没关系的，只要浏览器不关闭，这个打开的TCP连接只会在超时未响应或者重复开启TCP连接的时候进行复原，而这个超时连接时间应该是服务端进行设置的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/16/TCP连接的建立与关闭/" data-id="cjjmjmhsu000mrbmcx0lk2shy" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-偏向锁、轻量级锁、重量级锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/15/偏向锁、轻量级锁、重量级锁/" class="article-date">
  <time datetime="2018-04-15T07:40:38.000Z" itemprop="datePublished">2018-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/15/偏向锁、轻量级锁、重量级锁/">偏向锁、轻量级锁、重量级锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="偏向锁、轻量级锁、重量级锁"><a href="#偏向锁、轻量级锁、重量级锁" class="headerlink" title="偏向锁、轻量级锁、重量级锁"></a>偏向锁、轻量级锁、重量级锁</h1><p>​    在讲述Java的偏向锁之前，先对我在《Java中的锁》一文中提到的自旋锁做一下补充，并且总结一下锁在Java对象中的存储。</p>
<h3 id="自旋锁和自适应自旋"><a href="#自旋锁和自适应自旋" class="headerlink" title="自旋锁和自适应自旋"></a>自旋锁和自适应自旋</h3><p>​    自旋锁的表示为想要持有锁的线程不断的对能够获取锁的判断条件进行判断，直到能够拿到锁。这个过程中不断地自旋将会带来非常大的CPU消耗，所以这种普通的自旋锁的实现一般是有自旋时间或者次数限制，当到达限制的时候还没有拿到锁，那么将会采取方法把线程挂起。<br>    在JDK1.6中，引入了自适应的自旋锁，也就意味着自旋锁的自旋的次数不再是固定不变的，而是由上一个在同一个锁上的自旋时间以及锁的拥有着的状态来决定的：如果在同一个锁   对象上，自旋等待刚刚成功获得了锁，并且持有锁的线程正在运行中，那么虚拟机会认为这个锁这次自旋也有可能成功，进而将允许自旋等待持续相对时间更长；对于某个锁，如果自旋很少成功获得过，那在以后要获取这个锁将可能省略自旋条件，避免浪费处理器资源。</p>
<h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p>​    在Java中，synchronized所采用的锁是保存在Java对象头里面的，Java在32位或者64位机器上，对于对象头存储采用的大小是不同的，在32位系统里采用32bit存储，64位系统采用64bit存储。<br>    在32位系统里面，对象头的MarkWord里面有25位存储对象的hashCode，也就是存储对象指向类元数据的指针，有4bit存储对象分代年龄，1bit用来表示是否是偏向锁，2bit来存储锁标志位。</p>
<table>
<thead>
<tr>
<th>存储内容</th>
<th>标志位</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象哈希码、对象分代年龄</td>
<td>01</td>
<td>未锁定</td>
</tr>
<tr>
<td>指向锁记录的指针</td>
<td>00</td>
<td>轻量级锁定</td>
</tr>
<tr>
<td>指向重量级锁的指针</td>
<td>10</td>
<td>膨胀（重量级锁定）</td>
</tr>
<tr>
<td>空，不需要记录信息</td>
<td>11</td>
<td>GC标记</td>
</tr>
<tr>
<td>偏向线程ID、偏向时间戳、对象分代年龄</td>
<td>01</td>
<td>可偏向</td>
</tr>
</tbody>
</table>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>​    偏向锁是指一个线程持有锁之后，在对象头和栈帧中规定锁记录里存储锁偏向的线程ID，之后该线程退出或者进入这个锁都将不会进行CAS来加锁或者解锁，只需要测试MarkWord里面的标识。如果测试成功，表示线程已经获得了锁，否则测试一下在MarkWord中偏向锁的标识是否设置为1，没有的话采用CAS竞争锁，已经有了的话将对象头的偏向锁指向当前线程。<br>    如果有两个或者多个线程同时竞争锁的时候或者已经有一个线程持有锁另外一个线程申请获得锁，那么这个时候这个锁膨胀为轻量级锁。<br>    偏向锁的目标是消除数据在无竞争情况下的同步源于，将进一步提高程序的并行性能。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>​    轻量级锁是存在多个线程竞争同一把偏向锁的时候，偏向锁膨胀形成的锁。<br>    在不存在竞争的时候，轻量级锁使用CAS操作进行加锁，因为不使用信号量，所以相对于重量级锁减少了开销，但是当存在竞争的时候，轻量级锁不在有效，将膨胀为重量级锁，等待获取锁的进程将会被阻塞。<br>    在锁竞争的情况下，轻量级锁是可以先通过自旋的方法来获取锁，如果多次获取不成功在将锁膨胀为重量级锁，通过这种方法来减少一定的开销。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>​    重量级锁就是通常意义上的互斥锁，重量锁通过将访问竞态条件的其他线程阻塞，来实现在并发的条件下的安全性。</p>
<h4 id="偏向锁、轻量级锁、重量级锁-偏向锁、轻量级锁的状态转"><a href="#偏向锁、轻量级锁、重量级锁-偏向锁、轻量级锁的状态转" class="headerlink" title="偏向锁、轻量级锁、重量级锁/偏向锁、轻量级锁的状态转"></a>偏向锁、轻量级锁、重量级锁/偏向锁、轻量级锁的状态转</h4><p><img src="/2018/04/15/偏向锁、轻量级锁、重量级锁/偏向锁、轻量级锁的状态转化.png" alt="偏向锁、轻量级锁的状态转化"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/15/偏向锁、轻量级锁、重量级锁/" data-id="cjjmjmhsx000srbmcv5dyhmoi" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/锁/">锁</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java中的锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/15/Java中的锁/" class="article-date">
  <time datetime="2018-04-15T07:39:45.000Z" itemprop="datePublished">2018-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/15/Java中的锁/">Java中的锁 </a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h1><p>​    在《同步语义-synchronized+final》一文中，我提到了Java中的锁–synchronized。synchronized在Java中是内置锁的实现，通过将方法、变量或者对象设为synchronized来实现自动的加锁和解锁步骤。<br>    但是在Java中，还有多种或显式或隐式的锁来实现并发编程，在这里详细的整理一下。</p>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p>​    在Java里，锁能够按照多种方式区分：</p>
<blockquote>
<p>依据线程执行的<code>公平性</code>：公平锁和非公平锁<br>依据能否<code>有多个线程持有同一个锁</code>：共享锁和独占锁、互斥锁和读写锁<br>按照线程<code>加锁的态度</code>：乐观锁和悲观锁<br>依据线程<code>持有锁的程度</code>：偏向锁和轻量级锁和重量级锁<br>除此之外，还有：分段锁、可重入锁、自旋锁、阻塞锁</p>
</blockquote>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>​    从宏观上讲，锁分为乐观锁和悲观锁。</p>
<h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>​    乐观锁对上锁保持一种乐观态度，即认为在线程执行过程中，读多写少，遇到并发写的时间较少，所以采用不加锁的方式，也就是无锁编程。在Java中，实现乐观锁的方式为循环CAS方法，只通过在数据提交时的比对，来判断是否应该进行数据更新。这种方式存在ABA问题，循环时间过长的时候开销大，只能保证一个共享变量的原子操作。乐观锁的一致性比悲观锁差，但是对于种地程度的并发，效率大大提高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CAS的实现：</span><br><span class="line">	compareAndSet(int v, int a);</span><br></pre></td></tr></table></figure>
<h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><p>​    悲观锁对上锁保持悲观态度，即认为在线程执行过程中，写多读少，遇到并发写的时间较多，所以对于每次读写数据的时候都会进行上锁。在Java中，独占锁或synchronized的实现都是悲观锁的实现。悲观锁的安全性高，更适合高并发的情况。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>​    自旋锁是指线程A想要获取一个锁，但是这个锁被其他线程持有，所以A通过不断地循环来判断锁是否已经被释放，当前可用。<br>    自旋锁在自旋时候并不会释放CPU，所以持有自旋锁的线程需要尽快的释放锁，以让其他需要占有的线程持有锁，防止不断地自旋消耗CPU资源。而如果持有锁的线程不是尽快释放锁，而是将其他线程堵塞，这种实现是阻塞锁。<br>    持有自旋锁的线程在睡眠前或者任务结束后，应当立即释放锁以便让其他线程能够获得锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">自旋锁的实现：</span><br><span class="line">	public void lock() &#123;</span><br><span class="line">        int myticket = ticketNum.getAndIncrement();</span><br><span class="line">        LOCAL.set(myticket);</span><br><span class="line">        while (myticket != serviceNum.get()) &#123;			//在这里还使用了CAS方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="阻塞锁"><a href="#阻塞锁" class="headerlink" title="阻塞锁"></a>阻塞锁</h3><p>​    阻塞锁指的是让线程进入阻塞状态进行等待，当获得相应的通知的时候唤醒进程，就绪状态的所有线程通过竞争的方式进入运行状态。<br>    在Java中，重量级锁、ReentrantLock都包含阻塞锁的实现。阻塞锁相对于自旋锁来说，降低了CPU的使用率，但是效率不一定比自旋锁高，因为线程的唤醒进入时间以及回复时间都比自旋锁慢。<br>    在竞争激烈的情况下 阻塞锁的性能要明显高于 自旋锁。理想的情况是; 在线程竞争不激烈的情况下，使用自旋锁，竞争激烈的情况下使用，阻塞锁。</p>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>​    可重入锁是指能够重进入的锁，表示一个锁能够支持线程对一个资源的重复加锁。可重入锁有公平锁和非公平锁的实现。<br>    可重入锁中，通过维护一个计数器，来描述持有该锁的线程已经持有了多少次锁，每一次加锁都对应着一次解锁操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">可重入锁的实现：</span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc = c + acquires;</span><br><span class="line">                if (nextc &lt; 0) // overflow</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p>​    公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。而对于非公平锁，只要CAS能够设置同步状态成功，那么表示当前线程获取了锁。<br>    在Java中，ReentrantLock分别实现了公平锁和非公平锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">公平锁的实现：hasQueuedPredecessors()方法用于检查等待队列中有没有元素。</span><br><span class="line">if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">非公平锁的实现：</span><br><span class="line">if (c == 0) &#123;</span><br><span class="line">    if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h3><p>​    独占锁指每次只能有一个线程能够持有锁，ReentrantLock就是以独占方式实现的互斥锁。共享锁，允许读个线程同时持有锁，并发的访问共享资源，ReadWriteLock中的readLock就是一种共享锁的实现。</p>
<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>​    读写锁是Java对于处于读和写两种不同状态下的并发提供的一种锁。读写锁维护了两个锁：读锁和写锁，通过分离读锁和写锁，使得并发性相较于其他的独占锁有了提升。读写锁也是可以选择实现公平锁或者非公平锁。<br>    当有一个线程持有读锁的时候，如果有其他线程想要获得锁，那么便能够获得锁，此时维护的是一个共享锁，并且这个共享锁是支持重进入的。如果线程获取读锁的时候，已经有其他线程获取了写锁，那么这个线程将会进入等待状态。而写锁只有在没有任何线程访问的时候才能够获得，实质上是一个排它锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">写锁实现：</span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            int w = exclusiveCount(c);</span><br><span class="line">            if (c != 0) &#123;</span><br><span class="line">                // (Note: if c != 0 and w == 0 then shared count != 0)</span><br><span class="line">                if (w == 0 || current != getExclusiveOwnerThread())</span><br><span class="line">                    return false;</span><br><span class="line">                if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                // Reentrant acquire</span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                return false;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">读锁的实现：</span><br><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (exclusiveCount(c) != 0 &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                return -1;</span><br><span class="line">            int r = sharedCount(c);</span><br><span class="line">            if (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                if (r == 0) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = 1;</span><br><span class="line">                &#125; else if (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    if (rh == null ||</span><br><span class="line">                        rh.tid != LockSupport.getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    else if (rh.count == 0)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            return fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>​    分段锁是在HashMap中的一个实现。HashTable容器在竞争激烈的并发环境中的时候，由于线程会竞争统一把锁，所以会导致效率低下。所以在容器里假设有多把锁，每把锁用于锁容器中的一部分数据，当不同的线程访问不同的数据的时候，就会持有不同的锁，降低了锁竞争的现象，有效的提高并发效率，这种方法就是CurrentHashMap的锁分段技术，将数据分为一段一段的存储，一段数据具有一把锁，一个线程占有一把锁的时候，并不影响其他线程访问其他数据段。</p>
<h3 id="偏向锁、轻量级锁、重量级锁"><a href="#偏向锁、轻量级锁、重量级锁" class="headerlink" title="偏向锁、轻量级锁、重量级锁"></a>偏向锁、轻量级锁、重量级锁</h3><p>​    在synchronized一文中，我简单的提到了这三种锁，我将在一篇文章里详细的介绍这三种锁：<a href="http://langxiaokai.top/2018/04/15/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/" target="_blank" rel="noopener"> 偏向锁、轻量级锁、重量级锁</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/15/Java中的锁/" data-id="cjjmjmhsf0005rbmc3dqx802z" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/锁/">锁</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java中的并发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/14/Java中的并发/" class="article-date">
  <time datetime="2018-04-14T07:38:52.000Z" itemprop="datePublished">2018-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/14/Java中的并发/">Java中的并发 </a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java中的并发"><a href="#Java中的并发" class="headerlink" title="Java中的并发"></a>Java中的并发</h1><p>​    已经写过一些有关于并发的文章，然后统一整理一下：</p>
<h5 id="Java并发模型原理："><a href="#Java并发模型原理：" class="headerlink" title="Java并发模型原理："></a>Java并发模型原理：</h5><p>​    <a href="http://langxiaokai.top/2018/04/09/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">共享内存模型</a><br>    <a href="http://langxiaokai.top/2018/04/11/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/" target="_blank" rel="noopener">内存屏障</a><br>    <a href="http://langxiaokai.top/2018/04/12/%E5%90%8C%E6%AD%A5%E8%AF%AD%E4%B9%89-volatile/" target="_blank" rel="noopener">volatile</a><br>    <a href="http://langxiaokai.top/2018/04/13/%E5%90%8C%E6%AD%A5%E8%AF%AD%E4%B9%89-synchronized-final/" target="_blank" rel="noopener">synchronized和final</a><br>    <a href="http://langxiaokai.top/2018/04/13/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96/" target="_blank" rel="noopener">双重检查锁和延迟初始化</a><br>    <a href="http://langxiaokai.top/2018/04/13/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" target="_blank" rel="noopener">线程间通信</a><br>    <a href="http://langxiaokai.top/2018/04/14/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">Java内存模型</a></p>
<h5 id="Java中的锁及其实现"><a href="#Java中的锁及其实现" class="headerlink" title="Java中的锁及其实现"></a>Java中的锁及其实现</h5><p>​    <a href="http://langxiaokai.top/2018/04/15/Java%E4%B8%AD%E7%9A%84%E9%94%81/" target="_blank" rel="noopener">Java中的锁</a><br>    <a href="http://langxiaokai.top/2018/04/15/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/" target="_blank" rel="noopener">偏向锁、轻量级锁、重量级锁</a><br>    <a href="http://langxiaokai.top/2018/04/17/AQS/" target="_blank" rel="noopener">AQS的实现</a><br>    <a href="http://langxiaokai.top/2018/04/17/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock/" target="_blank" rel="noopener">可重入锁和读写锁</a><br>    <a href="http://langxiaokai.top/2018/04/18/Java%E4%B8%AD%E7%9A%84Concurrent%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Java中Concurrent类的实现</a></p>
<p>初步接触并发，若有错误，还请雅正。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/14/Java中的并发/" data-id="cjjmjmhsc0004rbmch6uc452u" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/文章整理/">文章整理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java内存模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/14/Java内存模型/" class="article-date">
  <time datetime="2018-04-14T07:36:54.000Z" itemprop="datePublished">2018-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/14/Java内存模型/">Java内存模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>​    在之前的一些有关并发的文章里面，掺杂着各种JMM有关的知识点，在这里加入JVM的内存统一整理一下。</p>
<h3 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h3><p>​    在《深入理解JVM》一书中，对Java的内存区域（运行时数据区）进行了比较明确的划分：<br><img src="/2018/04/14/Java内存模型/内存划分.png" alt="Java虚拟机运行时数据区"></p>
<blockquote>
<h6 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h6><blockquote>
<p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。常说的Java栈指的就是在Java虚拟机栈中的局部变量表部分。<br>局部变量表部分存储一直的基本数据类型对象引用和returnAddress类型。<br><code>在虚拟机栈中可能出现的错误：</code></p>
<blockquote>
<p>线程请求的栈深度大于虚拟机允许的深度，抛出StackOverFlowError异常。<br>扩展时无法申请到足够的内存，抛出OutOfMemoryError异常。</p>
</blockquote>
</blockquote>
<h6 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h6><blockquote>
<p>本地方法栈为虚拟机使用的Native方法进行服务，其他的基本类似于虚拟机栈。在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。</p>
</blockquote>
<h6 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h6><blockquote>
<p>Java堆(Java Heap)是Java虚拟机中管理的内存最大的一块，并且堆被所有的线程共享。堆会存放对象实例，在JVM规范中的描述是：所有的对象实例以及数组都要在堆上分配。<br>Java堆是垃圾收集器管理的主要区域，所以也被称为”GC堆”。还可能存在多种更为细致的划分，目的是更好的回收内存，或者更快的分配内存。<br>在JVM规范中，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的。<br><code>在堆中可能出现的错误</code></p>
<blockquote>
<p>如果在堆中没有内存完成实例分配，并且堆再也无法扩展时，将会抛出OutOfMemoryError异常。</p>
</blockquote>
</blockquote>
<h6 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h6><blockquote>
<p>方法区跟Java堆一样，是各个线程共享的内存区域，用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区也被称之为Non-Heap(非堆)，用以跟Java堆的区分。<br>在方法区中存在运行时常量池，用来存放编译期生成的各种字面量和符号引用以及存储翻译出来的直接引用，并且运行期常量池是能够在运行过程中进行添加的，比如String类的intern()方法。<br><code>常量池和运行期常量池辨析</code></p>
<blockquote>
<p>在Class文件中，除了有类的版本、字段、方法、借口等描述信息，还有常量池，常量池存放编译期生成的各种字面量和符号引用，这一部分内容会在类加载后刷入到方法区的运行时常量池中存储。<br>运行期常量池是方法区的一部分，并且能够在运行期间进行添加。</p>
</blockquote>
<p><code>方法区可能出现的错误</code></p>
<blockquote>
<p>当方法区无法满足内存分配时，将会抛出OutOfMemoryError异常。</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="Java内存模型-1"><a href="#Java内存模型-1" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>​    在Java中，采用的线程通信方式是共享内存模型，所以Java内存模型(Java  Memory  Model)的实现是通过共享内存的方法进行实现的。Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。<br>    Java的内存模型规定了所有的变量都储存在主内存，   每条线程还有自己的工作过内存，线程的工作内存保存了线程中使用到的主内存副本拷贝，线程的操作是对工作内存的操作，不允许直接操作主内存。并且线程之间的工作内存是互相隔离的，线程间的传递需要通过主内存，这也就是共享内存模型的内容。<br><img src="/2018/04/14/Java内存模型/信息交互.png" alt="线程、工作内存、主内存三者的交互关系"><br>    除去基本的内存模型，JMM保证了可见性、原子性、有序性。</p>
<blockquote>
<p>可见性的概念也就是内存可见性，JMM对于可见性的支持是采用了volatile关键字或者锁来保证可见性。<br>原子性的概念也就是在执行过程中，一个操作是不能够中断的，这之间存在线程之间的共享变量读取写入的问题。在JMM中，采用了synchronized来保证并发过程的安全性和操作的原子性。<br>有序性指的是在指令执行过程中的指令重排序现象，JMM采用了volatile、synchronized、final分别做到了不同的保证，来确保在多线程环境过程中的语义有序性，例如实现happens-before规则和as-if-serial语义。</p>
</blockquote>
<p>​    上述提到的JMM确保的规则，在其他文章中都有提及，这里不再复述。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/14/Java内存模型/" data-id="cjjmjmhsk0008rbmcum16zcol" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存模型/">内存模型</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-线程间通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/线程间通信/" class="article-date">
  <time datetime="2018-04-13T07:19:57.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/线程间通信/">线程间通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>​    我在《同步语义-volatile》一文中提到过共享内存和消息传递线程中的两种通信机制，但是在Java线程中的通信方式存在很多种，在这里整理了一下。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>​    通过设置共享变量，多个进程来访问共享变量，从而隐式的达到线程间的通信。</p>
<h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h3><p>​    是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。等待/通知机制是一种很典型的消息传递的机制。</p>
<h6 id="经典范例"><a href="#经典范例" class="headerlink" title="经典范例"></a>经典范例</h6><blockquote>
<p>等待方</p>
<blockquote>
<p>获取对象的锁<br>如果条件不满足，调用对象的wait()方法，被通知后仍要检查条件<br>条件满足执行对应逻辑</p>
<blockquote>
<p>伪代码<br>synchronized(对象) {<br>    while(条件不满足) {<br>        对象.wait();<br>    }<br>    对应的处理逻辑<br>}</p>
</blockquote>
</blockquote>
<p>通知方</p>
<blockquote>
<p>获得对象的锁<br>改变条件<br>通知所有等待在对象上的线程</p>
<blockquote>
<p>伪代码<br>synchronized(对象) {<br>    改变条件<br>    对象.notifyAll();</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>​    管道输入/输出和普通的文件输入/输出流或者网络输入/输出流不同之处在于它用于线程之间的数据传输，传输媒介为内存。</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>​    在Java中，线程之间的同步也就是通过volatile和synchronized关键字来进行数据同步。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/13/线程间通信/" data-id="cjjmjmhta001qrbmcc4s3rx95" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程通信/">线程通信</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java新特性/">Java新特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存屏障/">内存屏障</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存模型/">内存模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单例/">单例</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/双轴快排/">双轴快排</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/同步语义/">同步语义</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础/">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文章整理/">文章整理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂记/">杂记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码解读/">源码解读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/系统搭建/">系统搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程通信/">线程通信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/锁/">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Java新特性/" style="font-size: 10px;">Java新特性</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/内存屏障/" style="font-size: 10px;">内存屏障</a> <a href="/tags/内存模型/" style="font-size: 12px;">内存模型</a> <a href="/tags/单例/" style="font-size: 10px;">单例</a> <a href="/tags/双轴快排/" style="font-size: 10px;">双轴快排</a> <a href="/tags/同步语义/" style="font-size: 12px;">同步语义</a> <a href="/tags/基础/" style="font-size: 14px;">基础</a> <a href="/tags/并发/" style="font-size: 18px;">并发</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/文章整理/" style="font-size: 10px;">文章整理</a> <a href="/tags/杂记/" style="font-size: 10px;">杂记</a> <a href="/tags/源码解读/" style="font-size: 16px;">源码解读</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/系统搭建/" style="font-size: 10px;">系统搭建</a> <a href="/tags/线程通信/" style="font-size: 10px;">线程通信</a> <a href="/tags/计算机网络/" style="font-size: 10px;">计算机网络</a> <a href="/tags/锁/" style="font-size: 12px;">锁</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/21/Java中不可变的一般类型/">Java中不可变的一般类型 </a>
          </li>
        
          <li>
            <a href="/2018/04/18/Java中的Concurrent类的实现/">Java中的Concurrent类的实现 </a>
          </li>
        
          <li>
            <a href="/2018/04/17/可重入锁ReentrantLock和读写锁ReentrantReadWriteLock/">可重入锁ReentrantLock和读写锁ReentrantReadWriteLock </a>
          </li>
        
          <li>
            <a href="/2018/04/17/AQS/">AQS</a>
          </li>
        
          <li>
            <a href="/2018/04/16/TCP连接的建立与关闭/">TCP连接的建立与关闭</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>