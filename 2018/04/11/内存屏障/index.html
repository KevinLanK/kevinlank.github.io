<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>内存屏障 | Hexo</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">内存屏障</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">内存屏障</h1><div class="post-meta">Apr 11, 2018</div><div class="post-content"><h3 id="内存屏障是个啥？"><a href="#内存屏障是个啥？" class="headerlink" title="内存屏障是个啥？"></a>内存屏障是个啥？</h3><p>​    内存屏障，是计算机CPU在多核时代，通过数据拷贝，将一个处理器的内存状态对其他处理器可见。在百度百科中，内存屏障也被称呼为内存栅栏，内存栅障，屏障指令等。乍一看到内存栅栏这个这个名词，我还以为这个是跟Java栅栏是一个东西，但是实际上两者并不相同。<br>    在执行CPU指令的时候，CPU会对指令进行乱序执行，来优化性能（这一点我在《共享内存模型》一文中有提到过）。而在多线程的时候，乱序执行可能会导致代码的执行跟预期结果不同，内存屏障同时阻止指令排序行为的发生。<br><a id="more"></a></p>
<h3 id="内存屏障有啥用？"><a href="#内存屏障有啥用？" class="headerlink" title="内存屏障有啥用？"></a>内存屏障有啥用？</h3><p>​    在CPU层次，内存屏障分为两种：读屏障 Load Barrier 和写屏障 Store Barrier。读屏障表示在线程读取前，将主存的内容载入到缓存或者是线程内存里。写屏障表示在缓存或者线程内存里插入后，将更新写入到主内存里。<br>    通过内存屏障，主内存和缓存（线程内存）之间做到了数据统一，保证了可见性。也就是说通过内存屏障，已经达成了共享内存模型的可见性要求。</p>
<h3 id="内存屏障的缺陷"><a href="#内存屏障的缺陷" class="headerlink" title="内存屏障的缺陷"></a>内存屏障的缺陷</h3><p>​    通过内存屏障，保证了数据可见性，同时防止屏障两端指令的重排序。但是内存屏障做不到并发过程中的原子性，这个也就是volatile关键字仅仅能够提供可见性，却不能够提供原子性的原因，因为volatile的实现就是通过内存屏障来进行实现的。</p>
<blockquote>
<h5 id="内存屏障做不到原子性的原因"><a href="#内存屏障做不到原子性的原因" class="headerlink" title="内存屏障做不到原子性的原因:"></a>内存屏障做不到原子性的原因:</h5><p>当存在两个线程Ta和Tb以及一个共享变量count=0，第一时刻Ta读取了count的值，这个读操作采用了内存屏障，读取前将Ta线程的内存里的数据清空，然后将主存的count复制到Ta线程的内存。<br>Ta线程执行count的++操作，此时Tb线程读取count的值，此时主存内count的值为0。<br>Ta执行变量count的++操作结束，将数据写回。同时Tb将读取的count执行++操作。此时主存内count的值为1。<br>Tb将数据写回。此时主存内的count值仍为1。</p>
</blockquote>
<p>​    如果程序的执行是正确的，那么最终结果应该是count=2，但是因为在程序执行过程中不提供原子性支持，所以会出现错误。<br>    这一部分内容都是CPU层次的内存屏障，下面的内容是Java层次的内存屏障。</p>
<h3 id="Java内存屏障"><a href="#Java内存屏障" class="headerlink" title="Java内存屏障"></a>Java内存屏障</h3><p>​    Java内存屏障包括四种：<code>LoadStore</code>，<code>StoreStore</code>，<code>LoadLoad</code>，<code>StoreLoad</code>。也就是CPU层次的内存屏障两两结合。</p>
<blockquote>
<p>LoadLoad ：   对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。<br>StoreStore ： 对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。<br>LoadStore ：  对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。<br>StoreLoad  ：  对于这样的语句Store1; StoreLoad;  Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能，但是开销相对较大。</p>
</blockquote>
<h3 id="JVM层次对于内存屏障的实现"><a href="#JVM层次对于内存屏障的实现" class="headerlink" title="JVM层次对于内存屏障的实现"></a>JVM层次对于内存屏障的实现</h3><h4 id="volatile语义中的内存屏障"><a href="#volatile语义中的内存屏障" class="headerlink" title="volatile语义中的内存屏障"></a>volatile语义中的内存屏障</h4><p>​    volatile对于内存屏障实现是悲观的，对于volatile变量：</p>
<blockquote>
<p>每次写操作前插入StoreStore屏障，写操作后插入StoreLoad屏障<br>每次读操作前插入LoadLoad屏障，读操作后插入LoadStore屏障</p>
</blockquote>
<p>​    同样的，因为内存屏障的缺陷，volatile不能够表现出原子性的特性，仅仅能够提供内存可见性。</p>
<h4 id="final语义中的内存屏障"><a href="#final语义中的内存屏障" class="headerlink" title="final语义中的内存屏障"></a>final语义中的内存屏障</h4><p>​    在final域里，分别针对屏障做出了规则限制：</p>
<blockquote>
<h5 id="写final域"><a href="#写final域" class="headerlink" title="写final域"></a>写final域</h5><blockquote>
<p>JMM禁止编译器把final域的写重排序到构造函数外。<br>编译器会在final域的写之后，return之前，插入StoreStore屏障。</p>
</blockquote>
<h5 id="读final域"><a href="#读final域" class="headerlink" title="读final域"></a>读final域</h5><blockquote>
<p>初次读对象引用域初次读该对象包含的final域，JMM禁止处理器重排序这两个操作。</p>
</blockquote>
</blockquote>
<p>​    也就是说，对于final域，总是在一个对象的所有final域写入完毕后才能读取和引用。</p>
</div><div class="tags"><a href="/tags/并发/">并发</a><a href="/tags/内存屏障/">内存屏障</a></div><div class="post-nav"><a class="pre" href="/2018/04/12/同步语义-volatile/">同步语义-volatile</a><a class="next" href="/2018/04/09/共享内存模型/">共享内存模型</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Ubuntu/" style="font-size: 15px;">Ubuntu</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/锁/" style="font-size: 15px;">锁</a> <a href="/tags/文章整理/" style="font-size: 15px;">文章整理</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/Java新特性/" style="font-size: 15px;">Java新特性</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/TCP-IP/" style="font-size: 15px;">TCP/IP</a> <a href="/tags/源码解读/" style="font-size: 15px;">源码解读</a> <a href="/tags/系统搭建/" style="font-size: 15px;">系统搭建</a> <a href="/tags/内存屏障/" style="font-size: 15px;">内存屏障</a> <a href="/tags/双轴快排/" style="font-size: 15px;">双轴快排</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/单例/" style="font-size: 15px;">单例</a> <a href="/tags/同步语义/" style="font-size: 15px;">同步语义</a> <a href="/tags/杂记/" style="font-size: 15px;">杂记</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/线程通信/" style="font-size: 15px;">线程通信</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/17/HashMap在并发环境下出现的错误/">HashMap在并发环境下出现的错误</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/21/Java中不可变的一般类型/">Java中不可变的一般类型 </a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/18/Java中的Concurrent类的实现/">Java中的Concurrent类的实现 </a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/17/可重入锁ReentrantLock和读写锁ReentrantReadWriteLock/">可重入锁ReentrantLock和读写锁ReentrantReadWriteLock </a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/17/AQS/">AQS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/16/TCP连接的建立与关闭/">TCP连接的建立与关闭</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/15/偏向锁、轻量级锁、重量级锁/">偏向锁、轻量级锁、重量级锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/15/Java中的锁/">Java中的锁 </a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/14/Java中的并发/">Java中的并发 </a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/14/Java内存模型/">Java内存模型</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://cokid.cc" title="Cokid" target="_blank">Cokid</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>