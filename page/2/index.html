<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-双重检查锁和延迟初始化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/双重检查锁和延迟初始化/" class="article-date">
  <time datetime="2018-04-13T07:19:48.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/双重检查锁和延迟初始化/">双重检查锁和延迟初始化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="双重检查锁和延迟初始化"><a href="#双重检查锁和延迟初始化" class="headerlink" title="双重检查锁和延迟初始化"></a>双重检查锁和延迟初始化</h1><p>​    有幸听一位学长讲过一次关于Java中单例模式与静态成员初始化对比的一个知识点。第一个知识点是在完成一个final域的初始化之前，存在着能够读取值的可能性；第二个知识点是在并发中，对于单例模式的一种可以称作为优化设计的知识。恰巧学到了这些内容的知识点，重新读了一下内容，整理了一下。</p>
<h3 id="final初始化的一种读值可能性"><a href="#final初始化的一种读值可能性" class="headerlink" title="final初始化的一种读值可能性"></a>final初始化的一种读值可能性</h3><p>​    在《同步语义-synchronized+final》一文中，我描述过一种在并发过程中读取未正常初始化的final域的现象，也就是在构造函数中this引用逸出，导致指令重排序之后第二个线程在final域写入值前读取到了这个对象。当然，这是一种完全可以避免的操作，只要没有this逸出，那么JMM就会保证这个错误不会发生。<br>    final在另外一种情况下可能存在读取未初始化值的情况，是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Elvis &#123;</span><br><span class="line">    public static final Elvis INSTANCE = new Elvis();</span><br><span class="line">    private final int beltSize;</span><br><span class="line">    static final int CURRENT_YEAR = Calendar.getInstance().get(Calendar.YEAR);</span><br><span class="line">    private Elvis() &#123;</span><br><span class="line">        beltSize = CURRENT_YEAR - 1930;</span><br><span class="line">    &#125;</span><br><span class="line">    public int beltSize() &#123;</span><br><span class="line">        return beltSize;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Elvis wears a size &quot; + INSTANCE.beltSize() + &quot; belt.&quot;);</span><br><span class="line">        System.out.println(INSTANCE.CURRENT_YEAR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Elvis wears a size -1930 belt.</span><br><span class="line">2018</span><br><span class="line">来源：《Java解惑》</span><br></pre></td></tr></table></figure>
<p>​    如果初始化是正常的，那么这个程序的答案应该是2018-1930，但是在输出中，第一步的输出的数字是-1930，而INSTANCE.CURRENT_YEAR的值却是2018。<br>    问题出现在，构造器会用一个涉及静态域的CURRENT_YEAR来初始化beltSize，在JAVA中，初始化静态域会造成调用类的构造器来初始化，但是这个过程已经处在初始化过程中了，那么CURRENT_YEAR的值将设置为默认值，然后用来初始化beltSize，在之后才将CURRENT_YEAR进行初始化，当然已经不再起作用了。<br>    所以：</p>
<blockquote>
<p>在final类型的静态域被初始化之前，存在着读取其值的可能性<br>final类型的域只有在其初始化表达式是常量表达式才是常量</p>
</blockquote>
<p>​    对于这个问题，书中给出了建议：</p>
<blockquote>
<p>想改正一个类初始化循环，需要重新对静态域的初始器进行排序，使得任何一个初始器都出现在任何依赖于它的初始器之前。</p>
</blockquote>
<h3 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h3><p>​    在涉及双重检查锁和单例模式之前，先对延迟初始化的概念进行一下总结。<br>    在Java中，有的时候需要采用延迟初始化来降低初始化类和创建对象的开销，也就是说，只有在需要某个对象的时候才对这个对象进行初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class UnsafeLazyInitialization &#123;</span><br><span class="line">	private static Instance instance;</span><br><span class="line">	public static Instance getInstance() &#123;</span><br><span class="line">		if (instance == null) 			//操作1</span><br><span class="line">			instance = new Instance(); 	//操作2</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h3><p>​    在延迟初始化部分列举的例子，如果是在单线程环境下运行，那么这个不会出现问题。但是如果环境是在多线程环境下，当有两个线程A、B的时候，当A执行操作1，但B执行操作2的时候，因为指令重排序的关系，对象的内存地址已经被分配，但是并没有进行初始化。所以有可能存在A线程看到instance引用的对象还没有完成初始化的现象。<br>    对于这种现象，采用加锁的方法，来进行同步处理实现线程安全的延迟初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class SafeLazyInitialization &#123;</span><br><span class="line">    private static Instance instance;</span><br><span class="line">    public synchronized static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">            instance = new Instance();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    当有一个线程进行初始化过程的时候，另外的线程访问都会被阻塞，从而保证不会存在错误的初始化访问现象。但是因为每一次有线程访问这段同步代码的时候，都会进行加锁解锁操作，将会导致大量的系统开销。所以，在这个基础上，设计了“双重检查否定”的方法，来降低同步的开销。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleCheckedLocking &#123;                      //1</span><br><span class="line">    private static Instance instance;                    //2</span><br><span class="line">    public static Instance getInstance() &#123;               //3</span><br><span class="line">        if (instance == null) &#123;                          //4:第一次检查</span><br><span class="line">            synchronized (DoubleCheckedLocking.class) &#123;  //5:加锁</span><br><span class="line">                if (instance == null)                    //6:第二次检查</span><br><span class="line">                    instance = new Instance();           //7</span><br><span class="line">            &#125;                                            //8</span><br><span class="line">        &#125;                                                //9</span><br><span class="line">        return instance;                                 //10</span><br><span class="line">    &#125;                                                    //11</span><br><span class="line">&#125;                                                        //12</span><br></pre></td></tr></table></figure>
<p>​    在上述实现里，如果第一次检查instance部位null，那么就不需要执行加锁和初始化操作，从而减少系统开销。<br>    但是，同样的，建立了双重检查锁的方法，同样会造成不存在锁的时候的错误，也就是说，仍然有可能读取未正确初始化的对象。对于这种现象，采用volatile来防止指令重排序，从而保证线程安全。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>​    单例模式常用的有三种：饿汗式、懒汉式、嵌套类。<br>    在饿汉式模式中，可能会存在上述内容讲到的初始化依赖的现象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    //在自己内部定义自己的一个实例，只供内部调用</span><br><span class="line">    private static final Singleton instance = new Singleton();</span><br><span class="line">    //可能存在着初始化依赖的现象</span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">        //do something</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在懒汉式模式里，采用了双重检查锁否定的方法，同时将私有对象设置为volatile的，来保证线程安全性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static volatile Singleton instance=null;</span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">        //do something</span><br><span class="line">    &#125;</span><br><span class="line">    public static  Singleton getInstance()&#123;</span><br><span class="line">        if(instance==null)&#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                if(instance==null)&#123;</span><br><span class="line">                    instance=new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    嵌套类的模式，是三种方法里比较好的一种，通过这种方法，能够提供类似于饿汉式的线程安全性而不需要加锁增大系统开销，同时因为类加载器的初始化顺序，保证了不会存在静态final域的初始化问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class Singleton &#123;  </span><br><span class="line">    private static class SingleHolder &#123;  </span><br><span class="line">        private static final Singleton single = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static Singleton getSingle() &#123;return SingleHolder.single;&#125;  </span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/13/双重检查锁和延迟初始化/" data-id="cjjmji7gx0011dnmc6hsajl91" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单例/">单例</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-同步语义-synchronized-final" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/同步语义-synchronized-final/" class="article-date">
  <time datetime="2018-04-13T07:19:41.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/同步语义-synchronized-final/">同步语义-synchronized+final</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="同步语义-synchronized-final"><a href="#同步语义-synchronized-final" class="headerlink" title="同步语义-synchronized+final"></a>同步语义-synchronized+final</h1><h3 id="Java中的锁–synchronized"><a href="#Java中的锁–synchronized" class="headerlink" title="Java中的锁–synchronized"></a>Java中的锁–synchronized</h3><p>​    在并发编程中，synchronized一直是非常重要的角色。通过加锁解锁，让临界区互斥执行，并且释放一个锁的线程向获取同一个锁的线程发送消息。<br>    <img src="/2018/04/13/同步语义-synchronized-final/锁获取的状态.png" alt="锁获取过程中做到的线程通信"><br>    在上面的示意图中，A线程先进行加锁，然后更新a的值，A释放锁之后，线程A会把a的值刷回到主内存中，当B进行加锁的时候，会从主内存中重新读取数据，此时就拿到了最新的A改变的a的值，也就是在两个线程中间做到了通信。锁的这种通信方式也是JMM所采用的共享内存模型。<br>    在JDK1.6之后，对synchronized的语义进行了优化，让这个锁变的没有那么重量级了。</p>
<h3 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h3><p>​    在Java 1.6之后，在Java中，并发的锁有了四种状态：无锁状态、偏向锁、轻量级锁、重量级锁。<br>     在JMM的实现中，无锁状态指的是采用了CAS（CompareAndSet）算法对共享变量进行操作。</p>
<blockquote>
<h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><blockquote>
<p>在每次对共享数据进行刷新的时候，传入内存值，旧的预期值和要修改的值，当且仅当内存值和旧的预期值相同时，将这个值修改为要修改的值，否则返回错误。</p>
</blockquote>
<p>缺陷</p>
<blockquote>
<p>ABA问题。即如果存在两个线程T1和T2，T1使用CAS进行检查，在这期间，T2将数据A先修改到B，再将数据修改回A，T1检查数据是正确的，但是实际上数值已经被修改。<br>循环时间长开销大。<br>只能保证一个共享变量的原子操作。</p>
</blockquote>
</blockquote>
<p>​    三种锁的优劣：</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳米级的消耗的差距</td>
<td>如果线程中存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块的场景。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td>
<td>追求响应时间；同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量；同步块执行速度较长</td>
</tr>
</tbody>
</table>
<h3 id="synchronized在执行互斥代码时的步骤"><a href="#synchronized在执行互斥代码时的步骤" class="headerlink" title="synchronized在执行互斥代码时的步骤"></a>synchronized在执行互斥代码时的步骤</h3><blockquote>
<p>获得互斥锁<br>清空工作内存<br>拷贝变量的最新副本到工作内存<br>执行代码<br>将更改后的变量的值刷新到主内存<br>释放锁</p>
</blockquote>
<h3 id="final语义规则"><a href="#final语义规则" class="headerlink" title="final语义规则"></a>final语义规则</h3><p>​    对final域，在编译器和处理器之间遵循两个重排序规则：</p>
<blockquote>
<p>在构造函数内对一个final域的写入，与随后把这个构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。<br>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</p>
</blockquote>
<h5 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h5><p>​    JMM禁止编译器把final域的写重排序到构造函数之外。<br>    编译器会在final域的写之后，构造函数return之前，插入StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。<br>    通过上述两个写域的规则，JMM能够确保在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，也就是另外一个线程读到的final域的数据一定是期望的值。<br><img src="/2018/04/13/同步语义-synchronized-final/写final域时序图.png" alt="线程执行时序图"></p>
<h5 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h5><p>​    在读final域之前，编译器会在操作前面插入一个LoadLoad屏障。通过这个屏障，JMM可以确保在读一个final域之前，一定会先读包含这个final域的对象的引用。<br><img src="/2018/04/13/同步语义-synchronized-final/读final域时序图.png" alt="线程执行时序图"></p>
<h3 id="this逸出"><a href="#this逸出" class="headerlink" title="this逸出"></a>this逸出</h3><p>​    在执行对象的构造过程的时候，会存在一种诡异的现象：this逸出。也就是在对象构造过程中，对象的引用在对象未能够构造完成的情况下引用被赋值给其他线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class FinalReferenceEscapeExample &#123;</span><br><span class="line">    final int i;</span><br><span class="line">    static FinalReferenceEscapeExample obj;</span><br><span class="line">    public FinalReferenceEscapeExample() &#123;</span><br><span class="line">        i = 1;             //写final域</span><br><span class="line">        obj = this;        //this引用在这里逸出</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writer() &#123;</span><br><span class="line">        new FinalReferenceEscapeExample();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123;</span><br><span class="line">        if (obj != null) &#123;</span><br><span class="line">            int temp = obj.i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在上述代码中，当有两个线程A执行的writer()时候，在构造函数内部，如果发生重排序，即对象赋值先于final初始化发生，并且在这个过程中，线程B执行reader()方法，那么读取到的obj将是已经不为null的对象，接着读取到未初始化的final域i，发生错误。<br>    所以在函数构造过程中，要保证在构造函数返回前，被构造对象的引用不能够被其他线程看见。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/13/同步语义-synchronized-final/" data-id="cjjmji7gz0016dnmcquvjtnwe" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/同步语义/">同步语义</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-同步语义-volatile" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/12/同步语义-volatile/" class="article-date">
  <time datetime="2018-04-12T07:19:32.000Z" itemprop="datePublished">2018-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/12/同步语义-volatile/">同步语义-volatile</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="同步语义-volatile"><a href="#同步语义-volatile" class="headerlink" title="同步语义-volatile"></a>同步语义-volatile</h1><h3 id="volatile是啥"><a href="#volatile是啥" class="headerlink" title="volatile是啥"></a>volatile是啥</h3><p>​    volatile，在Java中保证了线程之间对于共享变量的同步，这里的同步，是指内存可见性，除去保证内存可见性，volatile语义还对JMM对于指令的重排序进行了禁止。</p>
<blockquote>
<p>提到volatile的同步，在线程中通信机制中，有两种方式来完成线程的通信：共享内存和消息传递（actor）。</p>
<h5 id="共享内存："><a href="#共享内存：" class="headerlink" title="共享内存："></a>共享内存：</h5><blockquote>
<p>是通过设置一个共享变量，多个线程来对这个共享变量进行读写操作，在读写过程中，不同的线程读取到的数据可能是其他线程写入的，这样就做到了隐式通信，同时需要指定方法或者变量之间的锁的关系来使得线程完成数据操作，这样做到了显示同步。</p>
</blockquote>
<h5 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h5><blockquote>
<p>消息传递是通过两个线程之间的消息队列，也就是线程A对线程B直接发起的消息通信，来完成信息传递。在这个过程中，线程之间没有公共状态，必须通过发送消息来显式进行通信，同时因为发送消息总是能够在接收消息之前，做到了隐式同步。</p>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th>并发模型</th>
<th>通信机制</th>
<th>同步机制</th>
</tr>
</thead>
<tbody>
<tr>
<td>共享内存</td>
<td>线程之间共享公共状态，通过写-读内存中的公共状态进行隐式通信。</td>
<td>必须指定线程的互斥执行顺序，做到显式同步。</td>
</tr>
<tr>
<td>消息传递</td>
<td>线程没有公共状态，所以必须通过发送消息来进行显式通信。</td>
<td>消息的发送必须在消息的接收之前，所以进行隐式的同步。</td>
</tr>
</tbody>
</table>
<h3 id="volatile的作用及实现"><a href="#volatile的作用及实现" class="headerlink" title="volatile的作用及实现"></a>volatile的作用及实现</h3><p>​     volatile能够对一个变量的读-写操作进行同步，对于单个变量的读-写操作，能够看成是使用同一个锁对读-写操作进行了同步。</p>
<blockquote>
<p>volatile特性：</p>
<blockquote>
<p>可见性：对一个volatile变量的读，总是能够看到（任意线程）对这个volatile变量最后的写入。<br>原子性：对单个volatile变量的读/写操作具有原子性，但是对于复合操作不具有原子性，哪怕这个复合操作是基于volatile变量。</p>
</blockquote>
</blockquote>
<p>​     volatile通过JSR-133定义的happens-before关系，来实现在两个线程之间的通信。</p>
<blockquote>
<h5 id="happens-before关系"><a href="#happens-before关系" class="headerlink" title="happens-before关系"></a>happens-before关系</h5><blockquote>
<p>如果一个操作执行的结果对另一个操作可见，那么这两个操作之间必须存在happens-before关系。这两个操作可以是在同一个线程之内，也可以在多个线程之间。</p>
<h6 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h6><blockquote>
<p>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。<br>监视器锁规则：对一个锁的解锁，happens-before于随后对于这个锁的加锁。<br>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。<br>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</p>
</blockquote>
</blockquote>
<h5 id="as-if-serial-语义"><a href="#as-if-serial-语义" class="headerlink" title="as-if-serial 语义"></a>as-if-serial 语义</h5><blockquote>
<p>as-if-serial语义是指：不管怎么重排序，（单线程）的执行结果不能被改变。</p>
</blockquote>
</blockquote>
<p>​      在写入一个共享volatile变量时，JMM会把该新城对应的本地内存中的共享变量值刷新到主内存；在读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，线程会从主内存中读取共享变量。通过对volatile变量写之后的写入主内存操作和读之前的从主内存读取操作，保证了可见性。<br>     volatile通过在JMM（Java Momery Modal）层次插入内存屏障，来做到对指令重排序的禁止。<br>     在JMM中，volatile对于内存屏障的实现是悲观的：</p>
<blockquote>
<p>每次写操作前插入StoreStore屏障，写操作后插入StoreLoad屏障<br>每次读操作前插入LoadLoad屏障，读操作后插入LoadStore屏障</p>
</blockquote>
<p>​    满足下列条件，volatile可以使用：</p>
<blockquote>
<p>对变量的写入不依赖变量的当前值<br>变量不包含在具有其他变量的不变式中</p>
</blockquote>
<h3 id="volatile为什么不能保证原子性"><a href="#volatile为什么不能保证原子性" class="headerlink" title="volatile为什么不能保证原子性"></a>volatile为什么不能保证原子性</h3><p>​     尽管volatile在内存可见性方面表现出了锁的状态，但是volatile并不是锁，所以不能够提供原子性。<br>     <img src="/2018/04/12/同步语义-volatile/VolatileTest.png" alt="volatile变量自增例子"><br>       在上面的这个程序中，如果在单线程中执行，那么这个操作将不会有错误，但是当放到并发环境中进行执行的时候，哪怕变量count是volatile变量，在写入之后能够将数据刷回主内存，但是这个程序依然是存在危险的。问题的原理同共享内存模型中不能够保持原子性的原理，即++操作属于复合操作，并非原子操作。</p>
<h3 id="volatile跟synchronized的差别"><a href="#volatile跟synchronized的差别" class="headerlink" title="volatile跟synchronized的差别"></a>volatile跟synchronized的差别</h3><p>​     synchronized实现可见性的时候，在线程角度执行互斥代码需要做到：</p>
<blockquote>
<p>获得互斥锁<br>清空工作内存<br>拷贝变量的最新副本到工作内存<br>执行代码<br>将更改后的变量的值刷新到主内存<br>释放锁</p>
</blockquote>
<p>​      volatile不是锁，但是volatile提供了原子变量在内存中的可见性，在并发设计中，这个操作将能够大大节省系统的开销。对于volatile的读，相当于synchronized的加锁，volatile的写，相当于synchronized的解锁，但是volatile不会阻塞线程，响应速度更快。</p>
<blockquote>
<p>volatile本质上是工作内存中的值不确定的，需要从主内存中重新读取；而synchronized本质是使用锁将变量锁定，只有当前变量可以访问，其他变量将被阻塞。<br>volatile只是存在于变量级别，而synchronized存在于变量，方法和类级别。<br>volatile只能怪保证内存可见性，不能保证原子性操作；而synchronized可以保证原子性和可见性。</p>
</blockquote>
<h3 id="关于volatile还需要知道什么"><a href="#关于volatile还需要知道什么" class="headerlink" title="关于volatile还需要知道什么"></a>关于volatile还需要知道什么</h3><p>​     volatile对于64位的Long类型变量有着优化。<br>       这一点需要从处理器总线的工作机制说起，在一些32位的处理器上，JVM运行时可能会把一个64位long/double类型的变量的写操作拆分为两个32位的写操作，并且将这两个32位的写操作分配到不同的总线事务中执行，此时这个64位变量的写操作不再具有原子性。同样的，读64位操作也是有可能是非原子的。通过将一个long/double变量声明为volatile的，JMM保证这些变量的set和get操作是原子的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/12/同步语义-volatile/" data-id="cjjmji7h10019dnmck7qd3ls2" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/同步语义/">同步语义</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-内存屏障" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/11/内存屏障/" class="article-date">
  <time datetime="2018-04-11T07:19:25.000Z" itemprop="datePublished">2018-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/11/内存屏障/">内存屏障</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><h3 id="内存屏障是个啥？"><a href="#内存屏障是个啥？" class="headerlink" title="内存屏障是个啥？"></a>内存屏障是个啥？</h3><p>​    内存屏障，是计算机CPU在多核时代，通过数据拷贝，将一个处理器的内存状态对其他处理器可见。在百度百科中，内存屏障也被称呼为内存栅栏，内存栅障，屏障指令等。乍一看到内存栅栏这个这个名词，我还以为这个是跟Java栅栏是一个东西，但是实际上两者并不相同。<br>    在执行CPU指令的时候，CPU会对指令进行乱序执行，来优化性能（这一点我在《共享内存模型》一文中有提到过）。而在多线程的时候，乱序执行可能会导致代码的执行跟预期结果不同，内存屏障同时阻止指令排序行为的发生。</p>
<h3 id="内存屏障有啥用？"><a href="#内存屏障有啥用？" class="headerlink" title="内存屏障有啥用？"></a>内存屏障有啥用？</h3><p>​    在CPU层次，内存屏障分为两种：读屏障 Load Barrier 和写屏障 Store Barrier。读屏障表示在线程读取前，将主存的内容载入到缓存或者是线程内存里。写屏障表示在缓存或者线程内存里插入后，将更新写入到主内存里。<br>    通过内存屏障，主内存和缓存（线程内存）之间做到了数据统一，保证了可见性。也就是说通过内存屏障，已经达成了共享内存模型的可见性要求。</p>
<h3 id="内存屏障的缺陷"><a href="#内存屏障的缺陷" class="headerlink" title="内存屏障的缺陷"></a>内存屏障的缺陷</h3><p>​    通过内存屏障，保证了数据可见性，同时防止屏障两端指令的重排序。但是内存屏障做不到并发过程中的原子性，这个也就是volatile关键字仅仅能够提供可见性，却不能够提供原子性的原因，因为volatile的实现就是通过内存屏障来进行实现的。</p>
<blockquote>
<h5 id="内存屏障做不到原子性的原因"><a href="#内存屏障做不到原子性的原因" class="headerlink" title="内存屏障做不到原子性的原因:"></a>内存屏障做不到原子性的原因:</h5><p>当存在两个线程Ta和Tb以及一个共享变量count=0，第一时刻Ta读取了count的值，这个读操作采用了内存屏障，读取前将Ta线程的内存里的数据清空，然后将主存的count复制到Ta线程的内存。<br>Ta线程执行count的++操作，此时Tb线程读取count的值，此时主存内count的值为0。<br>Ta执行变量count的++操作结束，将数据写回。同时Tb将读取的count执行++操作。此时主存内count的值为1。<br>Tb将数据写回。此时主存内的count值仍为1。</p>
</blockquote>
<p>​    如果程序的执行是正确的，那么最终结果应该是count=2，但是因为在程序执行过程中不提供原子性支持，所以会出现错误。<br>    这一部分内容都是CPU层次的内存屏障，下面的内容是Java层次的内存屏障。</p>
<h3 id="Java内存屏障"><a href="#Java内存屏障" class="headerlink" title="Java内存屏障"></a>Java内存屏障</h3><p>​    Java内存屏障包括四种：<code>LoadStore</code>，<code>StoreStore</code>，<code>LoadLoad</code>，<code>StoreLoad</code>。也就是CPU层次的内存屏障两两结合。</p>
<blockquote>
<p>LoadLoad ：   对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。<br>StoreStore ： 对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。<br>LoadStore ：  对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。<br>StoreLoad  ：  对于这样的语句Store1; StoreLoad;  Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能，但是开销相对较大。</p>
</blockquote>
<h3 id="JVM层次对于内存屏障的实现"><a href="#JVM层次对于内存屏障的实现" class="headerlink" title="JVM层次对于内存屏障的实现"></a>JVM层次对于内存屏障的实现</h3><h4 id="volatile语义中的内存屏障"><a href="#volatile语义中的内存屏障" class="headerlink" title="volatile语义中的内存屏障"></a>volatile语义中的内存屏障</h4><p>​    volatile对于内存屏障实现是悲观的，对于volatile变量：</p>
<blockquote>
<p>每次写操作前插入StoreStore屏障，写操作后插入StoreLoad屏障<br>每次读操作前插入LoadLoad屏障，读操作后插入LoadStore屏障</p>
</blockquote>
<p>​    同样的，因为内存屏障的缺陷，volatile不能够表现出原子性的特性，仅仅能够提供内存可见性。</p>
<h4 id="final语义中的内存屏障"><a href="#final语义中的内存屏障" class="headerlink" title="final语义中的内存屏障"></a>final语义中的内存屏障</h4><p>​    在final域里，分别针对屏障做出了规则限制：</p>
<blockquote>
<h5 id="写final域"><a href="#写final域" class="headerlink" title="写final域"></a>写final域</h5><blockquote>
<p>JMM禁止编译器把final域的写重排序到构造函数外。<br>编译器会在final域的写之后，return之前，插入StoreStore屏障。</p>
</blockquote>
<h5 id="读final域"><a href="#读final域" class="headerlink" title="读final域"></a>读final域</h5><blockquote>
<p>初次读对象引用域初次读该对象包含的final域，JMM禁止处理器重排序这两个操作。</p>
</blockquote>
</blockquote>
<p>​    也就是说，对于final域，总是在一个对象的所有final域写入完毕后才能读取和引用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/11/内存屏障/" data-id="cjjmji7gv000xdnmc34vnb4i3" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存屏障/">内存屏障</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-共享内存模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/09/共享内存模型/" class="article-date">
  <time datetime="2018-04-09T07:19:16.000Z" itemprop="datePublished">2018-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/09/共享内存模型/">共享内存模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="共享内存模型"><a href="#共享内存模型" class="headerlink" title="共享内存模型"></a>共享内存模型</h1><h3 id="共享内存模型-1"><a href="#共享内存模型-1" class="headerlink" title="共享内存模型"></a>共享内存模型</h3><p>​    在线程与锁之间，一个非常简单的并发模型是–共享内存模型。共享内存模型是指通过共享内存来实现并发的模型。<br>    共享内存模型中，当多个线程在并发执行过程中对共享资源进行处理时候，如果没有进行一定的同步处理，那么就会出现读脏、数据无效的问题。在共享内存模型中，非常重要的两个概念是：内存可见性+原子性。<br>    Java中多个线程之间的通信就是通过共享变量来进行的，JVM里面主内存是所有内存共享的，而每个线程拥有自己的工作内存，线程只能在自己的工作内存中处理数据。那么很明显的，在内存之间对共享变量处理过程就容易出现错误问题。<br>    <img src="/2018/04/09/共享内存模型/Untitled Diagram.png" alt="内存结构模型"></p>
<h4 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h4><p>​    内存可见性保证了Java多线程并发处理过程中，不同的线程对于共享资源的处理，能够保证始终被其他线程观察到。例如对某一个共享数据的处理，其他线程始终能够看到这个共享数据的最新值，无论这个数据是在哪一个线程中进行修改的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Counting &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">        class Counter &#123;</span><br><span class="line">            private int count = 0;</span><br><span class="line">            public void increment() &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            public int getCount() &#123;</span><br><span class="line">                return count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        final Counter counter = new Counter();</span><br><span class="line">        class CountingThread extends Thread &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int x=0;x&lt;10000;x++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        CountingThread t1 = new CountingThread();</span><br><span class="line">        CountingThread t2 = new CountingThread();</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(counter.getCount());</span><br><span class="line">    &#125;buding</span><br><span class="line">&#125;</span><br><span class="line">//程序来源：《Seven Concurrency Models in Seven Weeks》</span><br></pre></td></tr></table></figure>
<p>​    在上述代码中，有两个线程，分别对一个共享变量count进行+10000操作，如果程序是正常的，那么输出的值应该是20000，然而因为线程每次进行+1操作之后，修改的值对另一个线程不可见，而对数据进行更新到主内存的时间不定，所以多次测试结果都不相同。同样的，这个程序也违反了变量模型的原子性。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>​    并发的原子性表现为在多线程操作中，对于某一个共享变量的操作，每个线程的操作都应该是原子性的。例如在Java中，对于一个数据的自增，也就是X++，这个操作实际上是读-改-写模式的操作，当在多线程中操作的时候，可能会存在线程a进行读取。线程b进行读取，同时两个线程分别对其进行++操作，但是最终的结果可能是1，也就是++操作不是原子操作。<br>    维持原子操作的方法，在共享内存模型中，是对共享内存进行加锁操作。通过加锁操作，持有一个共享对象的锁，将一个线程对该对象的操作转换为原子操作，保证程序的原子性。</p>
<h4 id="非常诡异的现象"><a href="#非常诡异的现象" class="headerlink" title="非常诡异的现象"></a>非常诡异的现象</h4><p>​    在Java中，存在着一些非常有意思的操作：指令重排序（乱序执行）。当出现指令重排序的时候，<br>Java会打乱代码的执行顺序，也就是说，对于代码的执行会处于不可控状态，这个状态跟线程的乱序执行是一样的道理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">导致在执行过程中发生乱序执行的原因有这么几种情况：</span><br><span class="line">	编译器的静态优化可以打乱代码的执行顺序。</span><br><span class="line">    JVM的动态优化会打乱代码的执行顺序。</span><br><span class="line">    硬件可以通过乱序执行来优化其性能。</span><br></pre></td></tr></table></figure>
<p>​    乱序执行造成的影响：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Puzzle &#123;</span><br><span class="line">    static boolean answerReady = false;</span><br><span class="line">    static int answer = 0;</span><br><span class="line">    static Thread t1 = new Thread()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            answer = 42;</span><br><span class="line">            answerReady = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    static Thread t2 = new Thread()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (answerReady)</span><br><span class="line">                System.out.println(&quot;The meaning of life is: &quot; + answer + &quot;.&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.println(&quot;I don&apos;t know the answer.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//程序来源：《Seven Concurrency Models in Seven Weeks》</span><br></pre></td></tr></table></figure>
<p>​    上述代码中，正确的执行输出结果应该是：The meaning of life is:  42.但是当乱序执行的时候，可能会出现一种结果：The meaning of life is:  0.解决方案是Java中有些机制可以使程序在编译器、处理器优化时会对有数据依赖的禁止指令重排序，如：volatile、synchronized等。<br>    共享内存模型主要要满足两点需求：内存可见性和原子性，满足这个条件的线程是安全的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/09/共享内存模型/" data-id="cjjmji7gu000vdnmcdv4p5nxf" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存模型/">内存模型</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-检测String的不可变性及String赋值的实质" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/18/检测String的不可变性及String赋值的实质/" class="article-date">
  <time datetime="2018-03-18T07:18:58.000Z" itemprop="datePublished">2018-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/18/检测String的不可变性及String赋值的实质/">检测String的不可变性及String赋值的实质</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="检测String的不可变性及String赋值的实质"><a href="#检测String的不可变性及String赋值的实质" class="headerlink" title="检测String的不可变性及String赋值的实质"></a>检测String的不可变性及String赋值的实质</h1><h3 id="String实现"><a href="#String实现" class="headerlink" title="String实现"></a>String实现</h3><p>​    从学习Java不久，就有人跟我讲过String是不可变的，也就是新建出来的String对象就不能够进行改变，对其进行改变会新建一个String对象，并且对其进行赋值。阅读了一下String的源码实现，简单的了解了一下机制。<br>    首先String类是被定义为了final的，然后内部实现的数组也定义为了final，对于这个final的使用，我大概只是了解到在这里是防止String被继承，并且保证String的不可变性的。但是，还是理解不透彻，我就去百度搜了搜，在知乎看到了一个非常有意思的回答，然后自己实现了一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    @Stable</span><br><span class="line">    private final byte[] value;</span><br><span class="line">    private final byte coder;</span><br><span class="line">    private int hash; // Default to 0</span><br></pre></td></tr></table></figure>
<p>​    首先String的底层是通过一个byte数组来进行实现的，在百度的时候，我查到很多博客或者文章里面给出的String实现都是char数组，是JDK在版本更新改了底层实现。<br>    在我看到的知乎回答里面，对String的不变性有一个非常棒的解释。从实现的数组讲，final Array是不能够对数组里面的数据进行final的，也就是final数组无法阻止数据更变。<br><img src="/2018/03/18/检测String的不可变性及String赋值的实质/ArrayTest.png" alt="检测Array无法对自己内部元素进行数据final保护"><br>    String的防止改变的实现是将底层数据私有化，并且没有将内部数据开放，所以才可以实现了String 的不可变性。</p>
<h3 id="String的赋值检测"><a href="#String的赋值检测" class="headerlink" title="String的赋值检测"></a>String的赋值检测</h3><p><img src="/2018/03/18/检测String的不可变性及String赋值的实质/StringTest.png" alt="验证String的赋值"><br>    String的赋值实际上只是对引用的赋值，我写了段代码进行验证。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/18/检测String的不可变性及String赋值的实质/" data-id="cjjmji7h9001ndnmcfuon1ewc" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码解读/">源码解读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Vector自动增加数组容量的实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/13/Vector自动增加数组容量的实现/" class="article-date">
  <time datetime="2018-03-13T07:18:42.000Z" itemprop="datePublished">2018-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/13/Vector自动增加数组容量的实现/">Vector自动增加数组容量的实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Vector自动增加数组容量的实现"><a href="#Vector自动增加数组容量的实现" class="headerlink" title="Vector自动增加数组容量的实现"></a>Vector自动增加数组容量的实现</h1><p>​    昨天在了解到ArrayList的自动扩容之后，忽然想到在Java的另外一个类-Vector里面，实现了数组的自动增长，然后看源码了解了一下。</p>
        
          <p class="article-more-link">
            <a href="/2018/03/13/Vector自动增加数组容量的实现/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/13/Vector自动增加数组容量的实现/" data-id="cjjmji7gs000qdnmc03vw0o5p" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码解读/">源码解读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-双轴快排了解一下" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/12/双轴快排了解一下/" class="article-date">
  <time datetime="2018-03-12T07:18:22.000Z" itemprop="datePublished">2018-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/12/双轴快排了解一下/">双轴快排了解一下</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="双轴快排了解一下"><a href="#双轴快排了解一下" class="headerlink" title="双轴快排了解一下"></a>双轴快排了解一下</h1><p>​    在JDK1.7之前，Java在Arrays类包里使用的排序算法是快速排序，在JDK1.7之后，Arrays仍然使用快速排序，不过是从一般的快排转到了双轴快排。<br></p>
        
          <p class="article-more-link">
            <a href="/2018/03/12/双轴快排了解一下/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/12/双轴快排了解一下/" data-id="cjjmji7gw000zdnmcyc8fjxyz" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/双轴快排/">双轴快排</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-有趣的java.util.List" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/12/有趣的java.util.List/" class="article-date">
  <time datetime="2018-03-12T07:17:48.000Z" itemprop="datePublished">2018-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/12/有趣的java.util.List/">有趣的java.util.*List</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="有趣的java-util-List"><a href="#有趣的java-util-List" class="headerlink" title="有趣的java.util.*List"></a>有趣的java.util.*List</h1><p>​    阅读容器的源码，然后读到了一些有意思的东西。</p>
<h4 id="LinkedList-amp-ArrayList的底层关系"><a href="#LinkedList-amp-ArrayList的底层关系" class="headerlink" title="LinkedList&amp;ArrayList的底层关系"></a>LinkedList&amp;ArrayList的底层关系</h4><p>​    先从两个链表的底层实现看，LinkedList是通过继承AbstractSequentialList这个抽象类，实现List、Deque、接口实现的，而ArrayList是直接通过List实现的，所以，从底层实现看，LinkedList实现要更加复杂。</p>
<p><img src="/2018/03/12/有趣的java.util.List/20160908114958424.png" alt="图片来源：CSDN"></p>
<h5 id="底层的实现"><a href="#底层的实现" class="headerlink" title="底层的实现"></a>底层的实现</h5><p>​    在ArrayList类的内部，ArrayList构建了一个默认数组，对于有参构造器数组的长度默认为10，对于无参构造器ArrayList构造了一个默认的空的数组来进行实现。<br>    在Linkedlist类的内部，Linkedlist通过构建了一个双链表来进行实现。</p>
<h4 id="ArrayList的扩容"><a href="#ArrayList的扩容" class="headerlink" title="ArrayList的扩容"></a>ArrayList的扩容</h4><p>​    ArrayList通过一个数组来进行实现，那么数组的优点是能够快速的进行数据检索，但是插入和删除相较Linkedlist更加困难，除此之外，数组的特性也决定了扩容一个数组是非常困难的，然后阅读了一下源码内对于扩容的实现方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void ensureCapacity(int minCapacity) &#123;</span><br><span class="line">        if (minCapacity &gt; elementData.length</span><br><span class="line">            &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">                 &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br><span class="line"></span><br><span class="line">    private Object[] grow(int minCapacity) &#123;</span><br><span class="line">        return elementData = Arrays.copyOf(elementData,</span><br><span class="line">                                           newCapacity(minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object[] grow() &#123;</span><br><span class="line">        return grow(size + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int newCapacity(int minCapacity) &#123;</span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        if (newCapacity - minCapacity &lt;= 0) &#123;</span><br><span class="line">            if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">                return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">            if (minCapacity &lt; 0) // overflow</span><br><span class="line">                throw new OutOfMemoryError();</span><br><span class="line">            return minCapacity;</span><br><span class="line">        &#125;</span><br><span class="line">        return (newCapacity - MAX_ARRAY_SIZE &lt;= 0)</span><br><span class="line">            ? newCapacity</span><br><span class="line">            : hugeCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">        if (minCapacity &lt; 0) // overflow</span><br><span class="line">            throw new OutOfMemoryError();</span><br><span class="line">        return (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">            ? Integer.MAX_VALUE</span><br><span class="line">            : MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​    能够看到，ArrayList建立一个新的数组，这个数组的容量通过移位运算扩展为现在数组的1.5倍，然后将原数组复制到新数组之中，在将引用转向原数组来实现扩容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    final int s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    if ((s = size) == (elementData = this.elementData).length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">                     elementData, index + 1,</span><br><span class="line">                     s - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size = s + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在实际使用过程中，即添加一个新项，但是新项超出数组上限，然后调用方法进行数组扩容。</p>
<h4 id="LinkedList的实现-双链表"><a href="#LinkedList的实现-双链表" class="headerlink" title="LinkedList的实现-双链表"></a>LinkedList的实现-双链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Linkedlist实现：</span><br><span class="line"></span><br><span class="line">	transient int size = 0;</span><br><span class="line"></span><br><span class="line">    transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    transient Node&lt;E&gt; last;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    private static class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            this.item = element;</span><br><span class="line">            this.next = next;</span><br><span class="line">            this.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​    通过阅读源码，能够看到JDK对于LInkedlist的实现是采用了一个双链表，那么问题来了，为什么不采用单链表？我没有能够查找到相关信息，但是通过阅读源码，我发现Linkedlist在查找某一个结点的过程中是通过一种类似于折半查找的方法来进行查找，为什么说类似，是因为这种二分查找只进行一次，也就是在得到结点的位置的时候，通过比较位置的大小和链表的长度，来确定查找的范围。所以，能够推测，在整个链表的查找中，运用这种类似的前后方向不同的查找，所以，Linkedlist采用了双链表作为实现方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Linkedlist查找结点的方法：</span><br><span class="line"> Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">        if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            for (int i = 0; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            return x;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/12/有趣的java.util.List/" data-id="cjjmji7h7001ldnmckifowphs" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码解读/">源码解读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-有趣的java-util-List" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/12/有趣的java-util-List/" class="article-date">
  <time datetime="2018-03-12T07:17:48.000Z" itemprop="datePublished">2018-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/12/有趣的java-util-List/">有趣的java.util.*List</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="有趣的java-util-List"><a href="#有趣的java-util-List" class="headerlink" title="有趣的java.util.*List"></a>有趣的java.util.*List</h1><p>​    阅读容器的源码，然后读到了一些有意思的东西。</p>
        
          <p class="article-more-link">
            <a href="/2018/03/12/有趣的java-util-List/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/12/有趣的java-util-List/" data-id="cjjmji7h6001idnmci2u7cds3" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码解读/">源码解读</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java新特性/">Java新特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存屏障/">内存屏障</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存模型/">内存模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单例/">单例</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/双轴快排/">双轴快排</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/同步语义/">同步语义</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础/">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文章整理/">文章整理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂记/">杂记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码解读/">源码解读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/系统搭建/">系统搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程通信/">线程通信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/锁/">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Java新特性/" style="font-size: 10px;">Java新特性</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/内存屏障/" style="font-size: 10px;">内存屏障</a> <a href="/tags/内存模型/" style="font-size: 12px;">内存模型</a> <a href="/tags/单例/" style="font-size: 10px;">单例</a> <a href="/tags/双轴快排/" style="font-size: 10px;">双轴快排</a> <a href="/tags/同步语义/" style="font-size: 12px;">同步语义</a> <a href="/tags/基础/" style="font-size: 14px;">基础</a> <a href="/tags/并发/" style="font-size: 18px;">并发</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/文章整理/" style="font-size: 10px;">文章整理</a> <a href="/tags/杂记/" style="font-size: 10px;">杂记</a> <a href="/tags/源码解读/" style="font-size: 16px;">源码解读</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/系统搭建/" style="font-size: 10px;">系统搭建</a> <a href="/tags/线程通信/" style="font-size: 10px;">线程通信</a> <a href="/tags/计算机网络/" style="font-size: 10px;">计算机网络</a> <a href="/tags/锁/" style="font-size: 12px;">锁</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/21/Java中不可变的一般类型/">Java中不可变的一般类型 </a>
          </li>
        
          <li>
            <a href="/2018/04/18/Java中的Concurrent类的实现/">Java中的Concurrent类的实现 </a>
          </li>
        
          <li>
            <a href="/2018/04/17/可重入锁ReentrantLock和读写锁ReentrantReadWriteLock/">可重入锁ReentrantLock和读写锁ReentrantReadWriteLock </a>
          </li>
        
          <li>
            <a href="/2018/04/17/AQS/">AQS</a>
          </li>
        
          <li>
            <a href="/2018/04/16/TCP连接的建立与关闭/">TCP连接的建立与关闭</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>